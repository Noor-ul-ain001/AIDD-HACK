"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[1989],{2084:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2/week-3-simulation-integration/3-1-simulation-integration-techniques","title":"Week 3: Simulation Integration","description":"Overview","source":"@site/docs/module-2/week-3-simulation-integration/3-1-simulation-integration-techniques.md","sourceDirName":"module-2/week-3-simulation-integration","slug":"/module-2/week-3-simulation-integration/3-1-simulation-integration-techniques","permalink":"/docs/module-2/week-3-simulation-integration/3-1-simulation-integration-techniques","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-2/week-3-simulation-integration/3-1-simulation-integration-techniques.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"difficulty":"intermediate"},"sidebar":"tutorialSidebar","previous":{"title":"Week 2: Gazebo Basics","permalink":"/docs/module-2/week-2-gazebo-basics/2-1-introduction-to-gazebo"},"next":{"title":"Week 4: Advanced Simulation","permalink":"/docs/module-2/week-4-advanced-simulation/4-1-advanced-simulation-techniques"}}');var t=r(4848),a=r(8453);const o={sidebar_position:2,difficulty:"intermediate"},s="Week 3: Simulation Integration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Connecting ROS 2 to Simulation",id:"connecting-ros-2-to-simulation",level:2},{value:"ROS 2 Control Interface",id:"ros-2-control-interface",level:3},{value:"Robot Model Integration",id:"robot-model-integration",level:2},{value:"URDF to SDF Conversion",id:"urdf-to-sdf-conversion",level:3},{value:"Example Robot Integration",id:"example-robot-integration",level:3},{value:"Practical Integration Techniques",id:"practical-integration-techniques",level:2},{value:"Launch Files for Simulation",id:"launch-files-for-simulation",level:3},{value:"TF and Coordinate Frames",id:"tf-and-coordinate-frames",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:2},{value:"Simulation Fidelity",id:"simulation-fidelity",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"week-3-simulation-integration",children:"Week 3: Simulation Integration"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"This week focuses on integrating your ROS 2 applications with simulation environments, connecting real-world robot concepts with virtual testing platforms."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this week, you will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Integrate ROS 2 nodes with Gazebo simulation"}),"\n",(0,t.jsx)(n.li,{children:"Implement sensor simulation and data processing"}),"\n",(0,t.jsx)(n.li,{children:"Connect physical robot models to simulation"}),"\n",(0,t.jsx)(n.li,{children:"Validate robot behaviors in simulated environments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"connecting-ros-2-to-simulation",children:"Connecting ROS 2 to Simulation"}),"\n",(0,t.jsx)(n.h3,{id:"ros-2-control-interface",children:"ROS 2 Control Interface"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 Control provides a standardized interface for controlling robots, both real and simulated. This interface allows you to use the same control commands for both real robots and simulation."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Example: ROS 2 Control in Simulation\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass SimulationController(Node):\r\n    def __init__(self):\r\n        super().__init__('simulation_controller')\r\n        \r\n        # Subscribe to sensor data from simulation\r\n        self.sensor_sub = self.create_subscription(\r\n            JointState,\r\n            '/joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n        \r\n        # Publish control commands to simulated robot\r\n        self.cmd_vel_pub = self.create_publisher(\r\n            Twist,\r\n            '/cmd_vel',\r\n            10\r\n        )\r\n        \r\n    def joint_state_callback(self, msg):\r\n        # Process joint state information from simulation\r\n        self.get_logger().info(f'Received joint states: {len(msg.name)} joints')\r\n</`\r\n\r\n### Hardware Abstraction Layer\r\n\r\nThe hardware abstraction layer (HAL) allows the same ROS 2 nodes to work with both real robots and simulations:\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Real Robot      Simulation\r\n|                |\r\n| Hardware       | Gazebo\r\n| Interface      | Plugins\r\n|                |\r\n+----------------+\r\n|\r\nROS 2 Control\r\n|\r\nApplication"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\r\n## Sensor Simulation\r\n\r\n### Simulating Real Sensors\r\n\r\nGazebo provides plugins for simulating various sensor types:\r\n\r\n1. **Camera Sensors**: Simulate RGB, depth, and thermal cameras\r\n2. **Lidar Sensors**: Simulate 2D and 3D LIDAR systems\r\n3. **IMU Sensors**: Simulate inertial measurement units\r\n4. **Force/Torque Sensors**: Simulate force and torque measurements\r\n\r\n### Sensor Data Processing\r\n\r\n```python\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, Image, CameraInfo\r\n\r\nclass SensorDataProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_processor')\r\n        \r\n        # Subscribe to simulated sensor data\r\n        self.lidar_sub = self.create_subscription(\r\n            LaserScan,\r\n            '/scan',\r\n            self.lidar_callback,\r\n            10\r\n        )\r\n        \r\n        self.camera_sub = self.create_subscription(\r\n            Image,\r\n            '/camera/image_raw',\r\n            self.camera_callback,\r\n            10\r\n        )\r\n        \r\n    def lidar_callback(self, msg):\r\n        # Process simulated LIDAR data\r\n        self.get_logger().info(f'LIDAR range data: {len(msg.ranges)} points')\r\n        \r\n    def camera_callback(self, msg):\r\n        # Process simulated camera data\r\n        self.get_logger().info(f'Camera image: {msg.width}x{msg.height}')\n"})}),"\n",(0,t.jsx)(n.h2,{id:"robot-model-integration",children:"Robot Model Integration"}),"\n",(0,t.jsx)(n.h3,{id:"urdf-to-sdf-conversion",children:"URDF to SDF Conversion"}),"\n",(0,t.jsx)(n.p,{children:"When using robots in Gazebo, URDF models are often converted to SDF format. The conversion process includes:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visual Elements"}),": Converting meshes and materials"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collision Elements"}),": Defining collision boundaries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physical Properties"}),": Mass, inertia, friction parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Joints and Transmissions"}),": Motor characteristics and control interfaces"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-robot-integration",children:"Example Robot Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- URDF snippet with Gazebo integration --\x3e\r\n<link name="camera_link">\r\n  <visual>\r\n    <geometry>\r\n      <box size="0.02 0.08 0.04"/>\r\n    </geometry>\r\n  </visual>\r\n  <collision>\r\n    <geometry>\r\n      <box size="0.02 0.08 0.04"/>\r\n    </geometry>\r\n  </collision>\r\n  <inertial>\r\n    <mass value="0.01"/>\r\n    <inertia ixx="1e-6" ixy="0" ixz="0" iyy="1e-6" iyz="0" izz="1e-6"/>\r\n  </inertial>\r\n</link>\r\n\r\n<gazebo reference="camera_link">\r\n  <sensor type="camera" name="camera1">\r\n    <update_rate>30.0</update_rate>\r\n    <camera name="head">\r\n      <horizontal_fov>1.3962634</horizontal_fov>\r\n      <image>\r\n        <width>800</width>\r\n        <height>600</height>\r\n        <format>R8G8B8</format>\r\n      </image>\r\n      <clip>\r\n        <near>0.02</near>\r\n        <far>300</far>\r\n      </clip>\r\n    </camera>\r\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\r\n      <ros>\r\n        <namespace>/camera</namespace>\r\n        <remapping>~/image_raw:=/camera/image_raw</remapping>\r\n        <remapping>~/camera_info:=/camera/camera_info</remapping>\r\n      </ros>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practical-integration-techniques",children:"Practical Integration Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"launch-files-for-simulation",children:"Launch Files for Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Create launch files that seamlessly switch between real robot and simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\nfrom launch.substitutions import PathJoinSubstitution\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare arguments\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n    \r\n    # Robot controller node\r\n    robot_controller = Node(\r\n        package='my_robot_controller',\r\n        executable='controller_node',\r\n        parameters=[\r\n            {'use_sim_time': use_sim_time}  # Switch behavior based on sim time\r\n        ]\r\n    )\r\n    \r\n    return LaunchDescription([\r\n        DeclareLaunchArgument(\r\n            'use_sim_time',\r\n            default_value='false',\r\n            description='Use simulation time if true'\r\n        ),\r\n        robot_controller\r\n    ])\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tf-and-coordinate-frames",children:"TF and Coordinate Frames"}),"\n",(0,t.jsx)(n.p,{children:"Ensure proper transformation frames work in both real and simulated environments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\n\r\nclass TFManager(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_manager')\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n        \r\n    def broadcast_transform(self, parent_frame, child_frame, transform):\r\n        t = TransformStamped()\r\n        \r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = parent_frame\r\n        t.child_frame_id = child_frame\r\n        \r\n        t.transform.translation.x = transform.translation.x\r\n        t.transform.translation.y = transform.translation.y\r\n        t.transform.translation.z = transform.translation.z\r\n        t.transform.rotation = transform.rotation\r\n        \r\n        self.tf_broadcaster.sendTransform(t)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,t.jsx)(n.h3,{id:"simulation-fidelity",children:"Simulation Fidelity"}),"\n",(0,t.jsx)(n.p,{children:"Evaluate how well your simulation matches real-world behavior:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kinematic Accuracy"}),": Do robot movements match reality?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Accuracy"}),": Do forces and accelerations match reality?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Accuracy"}),": Do simulated sensors provide realistic data?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timing Accuracy"}),": Do delays and update rates match reality?"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware-in-the-loop"}),": Connect real controllers to simulated robots"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"System identification"}),": Compare real and simulated system responses"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance validation"}),": Validate control algorithms in both environments"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,t.jsx)(n.p,{children:"This week's exercise involves integrating a complete robot system with Gazebo:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a robot model with sensors"}),"\n",(0,t.jsx)(n.li,{children:"Implement sensor processing nodes"}),"\n",(0,t.jsx)(n.li,{children:"Connect control systems to the simulated robot"}),"\n",(0,t.jsx)(n.li,{children:"Validate the system's performance against requirements"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This week covered the integration of ROS 2 systems with simulation environments. You've learned how to connect real robot concepts with virtual testing platforms. Next week, we'll explore advanced simulation techniques and optimization strategies."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(6540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);
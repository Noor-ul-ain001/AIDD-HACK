"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[2217],{5920:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"module-1/week-3-services-actions/3-2-understanding-actions","title":"3.2: Understanding ROS 2 Actions","description":"Overview","source":"@site/docs/module-1/week-3-services-actions/3-2-understanding-actions.md","sourceDirName":"module-1/week-3-services-actions","slug":"/module-1/week-3-services-actions/3-2-understanding-actions","permalink":"/docs/module-1/week-3-services-actions/3-2-understanding-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-1/week-3-services-actions/3-2-understanding-actions.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"difficulty":"beginner"},"sidebar":"tutorialSidebar","previous":{"title":"3.1: Understanding ROS 2 Services","permalink":"/docs/module-1/week-3-services-actions/3-1-understanding-services"},"next":{"title":"3.3: Comparison of Communication Patterns - Topic vs Service vs Action","permalink":"/docs/module-1/week-3-services-actions/3-3-comparison-topic-service-action"}}');var c=r(4848),a=r(8453);const t={sidebar_position:2,difficulty:"beginner"},l="3.2: Understanding ROS 2 Actions",o={},s=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Action Communication Pattern",id:"action-communication-pattern",level:2},{value:"When to Use Actions vs Services vs Topics",id:"when-to-use-actions-vs-services-vs-topics",level:3},{value:"Action Structure",id:"action-structure",level:2},{value:"Creating Action Servers in Python",id:"creating-action-servers-in-python",level:2},{value:"Basic Action Server",id:"basic-action-server",level:3},{value:"Creating Action Clients in Python",id:"creating-action-clients-in-python",level:2},{value:"Basic Action Client",id:"basic-action-client",level:3},{value:"Creating Actions in C++",id:"creating-actions-in-c",level:2},{value:"Action Server in C++",id:"action-server-in-c",level:3},{value:"Action Client in C++",id:"action-client-in-c",level:3},{value:"Custom Action Types",id:"custom-action-types",level:2},{value:"Creating Custom Actions",id:"creating-custom-actions",level:3},{value:"Using Custom Actions",id:"using-custom-actions",level:3},{value:"Advanced Action Patterns",id:"advanced-action-patterns",level:2},{value:"Action with Priority and Queueing",id:"action-with-priority-and-queueing",level:3},{value:"Action with Multiple Feedback Types",id:"action-with-multiple-feedback-types",level:3},{value:"Action Error Handling and Recovery",id:"action-error-handling-and-recovery",level:2},{value:"Robust Action Server with Error Handling",id:"robust-action-server-with-error-handling",level:3},{value:"Action Monitoring and Debugging",id:"action-monitoring-and-debugging",level:2},{value:"Command-Line Tools for Actions",id:"command-line-tools-for-actions",level:3},{value:"Action Type Information",id:"action-type-information",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Efficient Action Implementation",id:"efficient-action-implementation",level:3},{value:"Best Practices for Actions",id:"best-practices-for-actions",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"32-understanding-ros-2-actions",children:"3.2: Understanding ROS 2 Actions"})}),"\n",(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsx)(n.p,{children:"This submodule explores ROS 2 actions, which provide a goal-oriented communication pattern ideal for long-running tasks that may be preempted or require feedback during execution. Actions combine features of both services and topics."}),"\n",(0,c.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,c.jsx)(n.p,{children:"By the end of this submodule, you will:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Understand the action communication pattern in ROS 2"}),"\n",(0,c.jsx)(n.li,{children:"Create and implement action servers and clients in Python and C++"}),"\n",(0,c.jsx)(n.li,{children:"Work with built-in and custom action types"}),"\n",(0,c.jsx)(n.li,{children:"Implement goal handling with feedback and results"}),"\n",(0,c.jsx)(n.li,{children:"Compare action usage with topics and services"}),"\n",(0,c.jsx)(n.li,{children:"Apply appropriate use cases for actions"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"action-communication-pattern",children:"Action Communication Pattern"}),"\n",(0,c.jsxs)(n.p,{children:["ROS 2 actions implement a ",(0,c.jsx)(n.strong,{children:"goal-oriented"})," communication pattern with the following components:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Goal"}),": Request to perform a long-running task"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Feedback"}),": Periodic updates during task execution"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Result"}),": Final outcome when task completes (success or failure)"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Preemption"}),": Ability to cancel or replace an ongoing goal"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"when-to-use-actions-vs-services-vs-topics",children:"When to Use Actions vs Services vs Topics"}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{children:"Use Actions When"}),(0,c.jsx)(n.th,{children:"Use Services When"}),(0,c.jsx)(n.th,{children:"Use Topics When"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Long-running tasks"}),(0,c.jsx)(n.td,{children:"Immediate response needed"}),(0,c.jsx)(n.td,{children:"Continuous data"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Need feedback during execution"}),(0,c.jsx)(n.td,{children:"Simple request/reply"}),(0,c.jsx)(n.td,{children:"Asynchronous broadcast"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Tasks can be preempted"}),(0,c.jsx)(n.td,{children:"Configuration calls"}),(0,c.jsx)(n.td,{children:"Sensor streams"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Goal-oriented work"}),(0,c.jsx)(n.td,{children:"Validation checks"}),(0,c.jsx)(n.td,{children:"State publishing"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Cancelable operations"}),(0,c.jsx)(n.td,{children:"One-time processing"}),(0,c.jsx)(n.td,{children:"Status updates"})]})]})]}),"\n",(0,c.jsx)(n.h2,{id:"action-structure",children:"Action Structure"}),"\n",(0,c.jsx)(n.p,{children:"Each action type has three message definitions:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Goal"}),": Contains parameters for the action"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Result"}),": Contains the final outcome"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Feedback"}),": Contains intermediate updates during execution"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Example: ",(0,c.jsx)(n.code,{children:"Fibonacci.action"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"# Goal definition\r\nint32 order\r\n---\r\n# Result definition\r\nint32[] sequence\r\n---\r\n# Feedback definition\r\nint32[] sequence\n"})}),"\n",(0,c.jsx)(n.h2,{id:"creating-action-servers-in-python",children:"Creating Action Servers in Python"}),"\n",(0,c.jsx)(n.h3,{id:"basic-action-server",children:"Basic Action Server"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import time\r\nimport rclpy\r\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass FibonacciActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        \"\"\"Accept or reject a client request to begin an action.\"\"\"\r\n        self.get_logger().info('Received goal request')\r\n        # Accept all goals for this example\r\n        return GoalResponse.ACCEPT\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        \"\"\"Accept or reject a client request to cancel an action.\"\"\"\r\n        self.get_logger().info('Received cancel request')\r\n        return CancelResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        \"\"\"Execute the goal and provide feedback.\"\"\"\r\n        self.get_logger().info('Executing goal...')\r\n        \r\n        # Create feedback message\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.sequence = [0, 1]\r\n        \r\n        # Simulate long-running task\r\n        for i in range(1, goal_handle.request.order):\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                self.get_logger().info('Goal canceled')\r\n                return Fibonacci.Result()\r\n\r\n            # Update feedback\r\n            feedback_msg.sequence.append(\r\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\r\n            \r\n            # Publish feedback\r\n            goal_handle.publish_feedback(feedback_msg)\r\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\r\n            \r\n            # Sleep to simulate work\r\n            time.sleep(1)\r\n\r\n        # Check if we were canceled\r\n        if goal_handle.is_cancel_requested:\r\n            goal_handle.canceled()\r\n            self.get_logger().info('Goal canceled')\r\n            return Fibonacci.Result()\r\n\r\n        # Success\r\n        goal_handle.succeed()\r\n        result = Fibonacci.Result()\r\n        result.sequence = feedback_msg.sequence\r\n        self.get_logger().info(f'Result: {result.sequence}')\r\n        \r\n        return result\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    action_server = FibonacciActionServer()\r\n    rclpy.spin(action_server)\r\n    action_server.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,c.jsx)(n.h2,{id:"creating-action-clients-in-python",children:"Creating Action Clients in Python"}),"\n",(0,c.jsx)(n.h3,{id:"basic-action-client",children:"Basic Action Client"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import time\r\nimport rclpy\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass FibonacciActionClient(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_client')\r\n        self._action_client = ActionClient(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci')\r\n\r\n    def send_goal(self, order):\r\n        # Wait for action server\r\n        self._action_client.wait_for_server()\r\n        \r\n        # Create goal message\r\n        goal_msg = Fibonacci.Goal()\r\n        goal_msg.order = order\r\n        \r\n        # Send goal and get future\r\n        self._send_goal_future = self._action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback)\r\n        \r\n        # Add callback for when goal is accepted\r\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\r\n        \r\n        return self._send_goal_future\r\n\r\n    def goal_response_callback(self, future):\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected')\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted')\r\n        \r\n        # Get result future\r\n        self._get_result_future = goal_handle.get_result_async()\r\n        self._get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        self.get_logger().info(\r\n            f'Received feedback: {feedback_msg.feedback.sequence}')\r\n\r\n    def get_result_callback(self, future):\r\n        result = future.result().result\r\n        self.get_logger().info(f'Result: {result.sequence}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    action_client = FibonacciActionClient()\r\n    \r\n    # Send goal\r\n    future = action_client.send_goal(10)\r\n    \r\n    # Spin until goal is complete\r\n    rclpy.spin_until_future_complete(action_client, future)\r\n    \r\n    action_client.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,c.jsx)(n.h2,{id:"creating-actions-in-c",children:"Creating Actions in C++"}),"\n",(0,c.jsx)(n.h3,{id:"action-server-in-c",children:"Action Server in C++"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:'#include <memory>\r\n#include <rclcpp/rclcpp.hpp>\r\n#include <rclcpp_action/rclcpp_action.hpp>\r\n#include <example_interfaces/action/fibonacci.hpp>\r\n\r\nclass FibonacciActionServer : public rclcpp::Node\r\n{\r\npublic:\r\n    using Fibonacci = example_interfaces::action::Fibonacci;\r\n    using GoalHandleFibonacci = rclcpp_action::ServerGoalHandle<Fibonacci>;\r\n\r\n    FibonacciActionServer() : Node("fibonacci_action_server")\r\n    {\r\n        using namespace std::placeholders;\r\n\r\n        this->action_server_ = rclcpp_action::create_server<Fibonacci>(\r\n            this->get_node_base_interface(),\r\n            this->get_node_clock_interface(),\r\n            this->get_node_logging_interface(),\r\n            this->get_node_waitables_interface(),\r\n            "fibonacci",\r\n            std::bind(&FibonacciActionServer::handle_goal, this, _1, _2),\r\n            std::bind(&FibonacciActionServer::handle_cancel, this, _1),\r\n            std::bind(&FibonacciActionServer::handle_accepted, this, _1));\r\n    }\r\n\r\nprivate:\r\n    rclcpp_action::Server<Fibonacci>::SharedPtr action_server_;\r\n\r\n    rclcpp_action::GoalResponse handle_goal(\r\n        const rclcpp_action::GoalUUID & uuid,\r\n        std::shared_ptr<const Fibonacci::Goal> goal)\r\n    {\r\n        RCLCPP_INFO(this->get_logger(), "Received goal request with order %d", goal->order);\r\n        (void)uuid;\r\n        return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\r\n    }\r\n\r\n    rclcpp_action::CancelResponse handle_cancel(\r\n        const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n    {\r\n        RCLCPP_INFO(this->get_logger(), "Received cancel request");\r\n        (void)goal_handle;\r\n        return rclcpp_action::CancelResponse::ACCEPT;\r\n    }\r\n\r\n    void handle_accepted(const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n    {\r\n        using namespace std::placeholders;\r\n        // This needs to return quickly to avoid blocking the executor\r\n        std::thread{std::bind(&FibonacciActionServer::execute, this, _1), goal_handle}.detach();\r\n    }\r\n\r\n    void execute(const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n    {\r\n        RCLCPP_INFO(this->get_logger(), "Executing goal");\r\n\r\n        // Create messages\r\n        auto feedback = std::make_shared<Fibonacci::Feedback>();\r\n        auto result = std::make_shared<Fibonacci::Result>();\r\n\r\n        // Initialize sequence\r\n        feedback->sequence = {0, 1};\r\n        \r\n        auto goal = goal_handle->get_goal();\r\n        \r\n        for (int i = 1; i < goal->order; ++i) {\r\n            // Check if there is a cancel request\r\n            if (goal_handle->is_canceling()) {\r\n                result->sequence = feedback->sequence;\r\n                goal_handle->canceled(result);\r\n                RCLCPP_INFO(this->get_logger(), "Goal canceled");\r\n                return;\r\n            }\r\n\r\n            // Update sequence\r\n            feedback->sequence.push_back(\r\n                feedback->sequence[i] + feedback->sequence[i - 1]);\r\n            \r\n            // Publish feedback\r\n            goal_handle->publish_feedback(feedback);\r\n            RCLCPP_INFO(this->get_logger(), "Publishing feedback: %s",\r\n                       std::to_string(feedback->sequence.back()).c_str());\r\n\r\n            // Sleep to simulate work\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n        }\r\n\r\n        // Check if goal is done\r\n        if (rclcpp::ok()) {\r\n            result->sequence = feedback->sequence;\r\n            goal_handle->succeed(result);\r\n            RCLCPP_INFO(this->get_logger(), "Goal succeeded");\r\n        }\r\n    }\r\n};\n'})}),"\n",(0,c.jsx)(n.h3,{id:"action-client-in-c",children:"Action Client in C++"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cpp",children:'#include <functional>\r\n#include <future>\r\n#include <memory>\r\n#include <string>\r\n#include <thread>\r\n\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "rclcpp_action/rclcpp_action.hpp"\r\n#include "example_interfaces/action/fibonacci.hpp"\r\n\r\nclass FibonacciActionClient : public rclcpp::Node\r\n{\r\npublic:\r\n    using Fibonacci = example_interfaces::action::Fibonacci;\r\n    using GoalHandleFibonacci = rclcpp_action::ClientGoalHandle<Fibonacci>;\r\n\r\n    explicit FibonacciActionClient(const std::string & action_name)\r\n    : Node("fibonacci_action_client")\r\n    {\r\n        this->client_ptr_ = rclcpp_action::create_client<Fibonacci>(\r\n            this->get_node_base_interface(),\r\n            this->get_node_graph_interface(),\r\n            this->get_node_logging_interface(),\r\n            this->get_node_waitables_interface(),\r\n            action_name);\r\n    }\r\n\r\n    void send_goal() {\r\n        using namespace std::placeholders;\r\n\r\n        this->timer_ = this->create_wall_timer(\r\n            std::chrono::milliseconds(500),\r\n            std::bind(&FibonacciActionClient::send_goal, this));\r\n        \r\n        if (!this->client_ptr_->wait_for_action_server(std::chrono::seconds(10))) {\r\n            RCLCPP_ERROR(this->get_logger(), "Action server not available after waiting");\r\n            return;\r\n        }\r\n\r\n        // Create goal\r\n        auto goal_msg = Fibonacci::Goal();\r\n        goal_msg.order = 10;\r\n\r\n        // Set callbacks\r\n        auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions();\r\n        send_goal_options.goal_response_callback =\r\n            std::bind(&FibonacciActionClient::goal_response_callback, this, _1);\r\n        send_goal_options.feedback_callback =\r\n            std::bind(&FibonacciActionClient::feedback_callback, this, _1, _2);\r\n        send_goal_options.result_callback =\r\n            std::bind(&FibonacciActionClient::result_callback, this, _1);\r\n        \r\n        // Send goal\r\n        RCLCPP_INFO(this->get_logger(), "Sending goal");\r\n        this->future_goal_handle_ =\r\n            this->client_ptr_->async_send_goal(goal_msg, send_goal_options);\r\n            \r\n        // Cancel timer after first execution\r\n        this->timer_->cancel();\r\n    }\r\n\r\nprivate:\r\n    rclcpp_action::Client<Fibonacci>::SharedPtr client_ptr_;\r\n    rclcpp::TimerBase::SharedPtr timer_;\r\n    rclcpp_action::ClientGoalHandle<Fibonacci>::SharedPtr future_goal_handle_;\r\n\r\n    void goal_response_callback(std::shared_future<GoalHandleFibonacci::SharedPtr> future) {\r\n        auto goal_handle = future.get();\r\n        if (!goal_handle) {\r\n            RCLCPP_ERROR(this->get_logger(), "Goal was rejected by server");\r\n        } else {\r\n            RCLCPP_INFO(this->get_logger(), "Goal accepted by server, waiting for result");\r\n        }\r\n    }\r\n\r\n    void feedback_callback(\r\n        GoalHandleFibonacci::SharedPtr,\r\n        const std::shared_ptr<const Fibonacci::Feedback> feedback)\r\n    {\r\n        RCLCPP_INFO(this->get_logger(), "Received feedback: %s",\r\n                   std::to_string(feedback->sequence.back()).c_str());\r\n    }\r\n\r\n    void result_callback(const GoalHandleFibonacci::WrappedResult & result) {\r\n        switch (result.code) {\r\n            case rclcpp_action::ResultCode::SUCCEEDED:\r\n                RCLCPP_INFO(this->get_logger(), "Goal succeeded");\r\n                break;\r\n            case rclcpp_action::ResultCode::ABORTED:\r\n                RCLCPP_ERROR(this->get_logger(), "Goal was aborted");\r\n                return;\r\n            case rclcpp_action::ResultCode::CANCELED:\r\n                RCLCPP_ERROR(this->get_logger(), "Goal was canceled");\r\n                return;\r\n            default:\r\n                RCLCPP_ERROR(this->get_logger(), "Unknown result code");\r\n                return;\r\n        }\r\n\r\n        RCLCPP_INFO(this->get_logger(), "Result received:");\r\n        for (auto number : result.result->sequence) {\r\n            RCLCPP_INFO(this->get_logger(), " %ld", number);\r\n        }\r\n    }\r\n};\n'})}),"\n",(0,c.jsx)(n.h2,{id:"custom-action-types",children:"Custom Action Types"}),"\n",(0,c.jsx)(n.h3,{id:"creating-custom-actions",children:"Creating Custom Actions"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"Create an action directory in your package"}),"\n",(0,c.jsxs)(n.li,{children:["Define your action in a ",(0,c.jsx)(n.code,{children:".action"})," file:"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"# Navigation.action\r\nfloat32 target_x\r\nfloat32 target_y\r\nfloat32 target_theta\r\n---\r\nstring status\r\nint32 error_code\r\n---\r\nfloat32 current_x\r\nfloat32 current_y\r\nfloat32 current_theta\r\nfloat32 distance_remaining\n"})}),"\n",(0,c.jsxs)(n.ol,{start:"3",children:["\n",(0,c.jsx)(n.li,{children:"Update your package.xml:"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<build_depend>rosidl_default_generators</build_depend>\r\n<exec_depend>rosidl_default_runtime</exec_depend>\r\n<member_of_group>rosidl_interface_packages</member_of_group>\n"})}),"\n",(0,c.jsxs)(n.ol,{start:"4",children:["\n",(0,c.jsx)(n.li,{children:"Update CMakeLists.txt:"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-cmake",children:'find_package(rosidl_default_generators REQUIRED)\r\n\r\nrosidl_generate_interfaces(${PROJECT_NAME}\r\n  "action/Navigation.action"\r\n)\n'})}),"\n",(0,c.jsx)(n.h3,{id:"using-custom-actions",children:"Using Custom Actions"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"from my_robot_msgs.action import Navigation\r\n\r\nclass NavigationActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('navigation_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Navigation,\r\n            'navigate_to_pose',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        # Validate goal\r\n        if goal_request.target_x < 0 or goal_request.target_y < 0:\r\n            self.get_logger().warn('Invalid navigation goal')\r\n            return GoalResponse.REJECT\r\n        \r\n        self.get_logger().info(f'Accepting navigation goal: {goal_request.target_x}, {goal_request.target_y}')\r\n        return GoalResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing navigation goal...')\r\n        \r\n        feedback_msg = Navigation.Feedback()\r\n        result = Navigation.Result()\r\n        \r\n        # Simulate navigation\r\n        for step in range(100):\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                result.status = 'CANCELED'\r\n                result.error_code = 1\r\n                return result\r\n            \r\n            # Update feedback\r\n            feedback_msg.current_x = goal_handle.request.target_x * (step / 100.0)\r\n            feedback_msg.current_y = goal_handle.request.target_y * (step / 100.0)\r\n            feedback_msg.distance_remaining = (1 - step/100.0) * 10.0  # Simplified\r\n            \r\n            goal_handle.publish_feedback(feedback_msg)\r\n            \r\n            # Simulate movement\r\n            time.sleep(0.1)\r\n        \r\n        # Success\r\n        goal_handle.succeed()\r\n        result.status = 'SUCCESS'\r\n        result.error_code = 0\r\n        return result\n"})}),"\n",(0,c.jsx)(n.h2,{id:"advanced-action-patterns",children:"Advanced Action Patterns"}),"\n",(0,c.jsx)(n.h3,{id:"action-with-priority-and-queueing",children:"Action with Priority and Queueing"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import queue\r\nfrom rclpy.action import ActionServer, GoalResponse\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass PriorityActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('priority_action_server')\r\n        \r\n        # Priority queue for goals\r\n        self.goal_queue = queue.PriorityQueue()\r\n        self.current_goal = None\r\n        \r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        # For this example, higher order = higher priority (negative for min-heap)\r\n        priority = -goal_request.order\r\n        self.goal_queue.put((priority, goal_request))\r\n        \r\n        # Accept all goals to handle priority internally\r\n        return GoalResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        # This would implement priority-based goal handling\r\n        pass\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        return CancelResponse.ACCEPT\n"})}),"\n",(0,c.jsx)(n.h3,{id:"action-with-multiple-feedback-types",children:"Action with Multiple Feedback Types"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"from example_interfaces.action import Fibonacci\r\n\r\nclass DetailedFeedbackServer(Node):\r\n    def __init__(self):\r\n        super().__init__('detailed_feedback_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci_detailed',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        self.get_logger().info(f'Received Fibonacci goal for order {goal_request.order}')\r\n        return GoalResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing Fibonacci goal...')\r\n        \r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.sequence = [0, 1]\r\n        \r\n        for i in range(1, goal_handle.request.order):\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                result = Fibonacci.Result()\r\n                result.sequence = feedback_msg.sequence\r\n                return result\r\n\r\n            # Update sequence\r\n            next_value = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\r\n            feedback_msg.sequence.append(next_value)\r\n            \r\n            # Publish detailed feedback\r\n            goal_handle.publish_feedback(feedback_msg)\r\n            \r\n            # Log progression\r\n            self.get_logger().info(f'Fibonacci step {i+1}: {next_value}')\r\n            \r\n            # Simulate computation time\r\n            time.sleep(0.5)\r\n\r\n        # Success\r\n        goal_handle.succeed()\r\n        result = Fibonacci.Result()\r\n        result.sequence = feedback_msg.sequence\r\n        self.get_logger().info(f'Fibonacci complete: {result.sequence}')\r\n        \r\n        return result\n"})}),"\n",(0,c.jsx)(n.h2,{id:"action-error-handling-and-recovery",children:"Action Error Handling and Recovery"}),"\n",(0,c.jsx)(n.h3,{id:"robust-action-server-with-error-handling",children:"Robust Action Server with Error Handling"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer, GoalResponse, CancelResponse\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass RobustActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('robust_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci_robust',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        # Validate goal parameters\r\n        if goal_request.order < 0:\r\n            self.get_logger().error(f'Invalid order value: {goal_request.order}')\r\n            return GoalResponse.REJECT\r\n        \r\n        if goal_request.order > 100:  # Prevent excessive computation\r\n            self.get_logger().warn(f'Large order value: {goal_request.order}')\r\n        \r\n        self.get_logger().info(f'Accepting goal with order: {goal_request.order}')\r\n        return GoalResponse.ACCEPT\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        self.get_logger().info(f'Canceling goal with order: {goal_handle.request.order}')\r\n        return CancelResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Starting robust execution...')\r\n        \r\n        feedback_msg = Fibonacci.Feedback()\r\n        result = Fibonacci.Result()\r\n        \r\n        try:\r\n            # Initialize sequence\r\n            if goal_handle.request.order <= 0:\r\n                result.sequence = []\r\n                goal_handle.succeed()\r\n                return result\r\n            elif goal_handle.request.order == 1:\r\n                result.sequence = [0]\r\n                goal_handle.succeed()\r\n                return result\r\n            else:\r\n                feedback_msg.sequence = [0, 1]\r\n\r\n            # Execute with error handling\r\n            for i in range(1, goal_handle.request.order):\r\n                # Check for cancellation\r\n                if goal_handle.is_cancel_requested:\r\n                    goal_handle.canceled()\r\n                    result.sequence = feedback_msg.sequence\r\n                    return result\r\n\r\n                # Calculate next Fibonacci number\r\n                next_value = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\r\n                \r\n                # Check for overflow (simplified)\r\n                if next_value < 0:  # Simplified overflow check\r\n                    self.get_logger().error('Overflow detected in Fibonacci calculation')\r\n                    goal_handle.abort()\r\n                    result.sequence = feedback_msg.sequence\r\n                    return result\r\n\r\n                feedback_msg.sequence.append(next_value)\r\n                \r\n                # Publish feedback periodically\r\n                if i % 5 == 0:  # Publish every 5 steps to reduce overhead\r\n                    goal_handle.publish_feedback(feedback_msg)\r\n                \r\n                # Simulate processing time\r\n                time.sleep(0.01)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error during execution: {e}')\r\n            goal_handle.abort()\r\n            result.sequence = feedback_msg.sequence\r\n            return result\r\n\r\n        # Success\r\n        goal_handle.succeed()\r\n        result.sequence = feedback_msg.sequence\r\n        self.get_logger().info(f'Execution completed successfully with {len(result.sequence)} numbers')\r\n        \r\n        return result\n"})}),"\n",(0,c.jsx)(n.h2,{id:"action-monitoring-and-debugging",children:"Action Monitoring and Debugging"}),"\n",(0,c.jsx)(n.h3,{id:"command-line-tools-for-actions",children:"Command-Line Tools for Actions"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:'# List all actions\r\nros2 action list\r\n\r\n# Get information about a specific action\r\nros2 action info /fibonacci\r\n\r\n# Send a goal to an action\r\nros2 action send_goal /fibonacci example_interfaces/action/Fibonacci "{order: 5}"\r\n\r\n# Show action type definition\r\nros2 interface show example_interfaces/action/Fibonacci\n'})}),"\n",(0,c.jsx)(n.h3,{id:"action-type-information",children:"Action Type Information"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# View the structure of an action\r\nros2 interface show example_interfaces/action/Fibonacci\n"})}),"\n",(0,c.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,c.jsx)(n.h3,{id:"efficient-action-implementation",children:"Efficient Action Implementation"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import time\r\nfrom rclpy.action import ActionServer\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass EfficientActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('efficient_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci_efficient',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n    def goal_callback(self, goal_request):\r\n        # Quick validation without heavy computation\r\n        if goal_request.order < 0 or goal_request.order > 1000:\r\n            return GoalResponse.REJECT\r\n        return GoalResponse.ACCEPT\r\n\r\n    def execute_callback(self, goal_handle):\r\n        start_time = time.time()\r\n        \r\n        feedback_msg = Fibonacci.Feedback()\r\n        result = Fibonacci.Result()\r\n        \r\n        # Optimize feedback frequency based on task length\r\n        feedback_interval = max(1, goal_handle.request.order // 20)  # Max 20 feedbacks\r\n        \r\n        try:\r\n            # Pre-allocate list if possible\r\n            if goal_handle.request.order > 0:\r\n                sequence = [0] * goal_handle.request.order\r\n                if goal_handle.request.order > 1:\r\n                    sequence[1] = 1\r\n                \r\n                for i in range(2, goal_handle.request.order):\r\n                    if goal_handle.is_cancel_requested:\r\n                        goal_handle.canceled()\r\n                        result.sequence = sequence[:i]\r\n                        return result\r\n\r\n                    sequence[i] = sequence[i-1] + sequence[i-2]\r\n                    \r\n                    # Send feedback at intervals to reduce overhead\r\n                    if i % feedback_interval == 0:\r\n                        feedback_msg.sequence = sequence[:i+1]\r\n                        goal_handle.publish_feedback(feedback_msg)\r\n            else:\r\n                sequence = []\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Execution failed: {e}')\r\n            goal_handle.abort()\r\n            result.sequence = sequence\r\n            return result\r\n\r\n        # Success\r\n        goal_handle.succeed()\r\n        result.sequence = sequence\r\n        end_time = time.time()\r\n        \r\n        self.get_logger().info(\r\n            f'Completed Fibonacci({len(result.sequence)}) in {end_time-start_time:.2f}s')\r\n        \r\n        return result\n"})}),"\n",(0,c.jsx)(n.h2,{id:"best-practices-for-actions",children:"Best Practices for Actions"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Appropriate Use"}),": Use actions for long-running, goal-oriented tasks that need feedback"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Goal Validation"}),": Always validate goal parameters in goal_callback"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Cancellation Support"}),": Handle cancellation requests appropriately"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Feedback Frequency"}),": Balance feedback frequency to avoid network overhead"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Error Handling"}),": Implement proper error handling and recovery"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Resource Management"}),": Manage resources properly in long-running tasks"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Testing"}),": Test cancellation, preemption, and error scenarios"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,c.jsx)(n.p,{children:"This submodule covered ROS 2 actions in detail, including their structure, implementation in Python and C++, custom action types, error handling, and best practices. Actions are ideal for long-running tasks that require feedback and can be canceled. In the next submodule, we'll explore when to use each communication pattern (topics, services, actions) and their appropriate applications."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(6540);const c={},a=i.createContext(c);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);
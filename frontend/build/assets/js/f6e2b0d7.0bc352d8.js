"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[5767],{5256:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises","title":"4.4: Practical Exercises - TF2 and URDF Integration","description":"Overview","source":"@site/docs/module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises.md","sourceDirName":"module-1/week-4-tf-urdf","slug":"/module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises","permalink":"/docs/module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"difficulty":"beginner"},"sidebar":"tutorialSidebar","previous":{"title":"4.3: Integration of TF2 and URDF in Robotic Systems","permalink":"/docs/module-1/week-4-tf-urdf/4-3-integration-tf2-urdf"},"next":{"title":"2.1: Overview of Robot Simulation","permalink":"/docs/module-2/week-1-introduction/2-1-overview-of-robot-simulation"}}');var s=n(4848),a=n(8453);const i={sidebar_position:4,difficulty:"beginner"},o="4.4: Practical Exercises - TF2 and URDF Integration",l={},m=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Exercise 1: Building a Complete Robot Model",id:"exercise-1-building-a-complete-robot-model",level:2},{value:"Objective",id:"objective",level:3},{value:"Step 1: Create the Package Structure",id:"step-1-create-the-package-structure",level:3},{value:"Step 2: Create the URDF Model",id:"step-2-create-the-urdf-model",level:3},{value:"Step 3: Update Package Files",id:"step-3-update-package-files",level:3},{value:"Exercise 2: Sensor Data Transformation",id:"exercise-2-sensor-data-transformation",level:2},{value:"Objective",id:"objective-1",level:3},{value:"Exercise 3: TF Visualization and Analysis",id:"exercise-3-tf-visualization-and-analysis",level:2},{value:"Exercise 4: Robot State Publisher with Sensor Integration",id:"exercise-4-robot-state-publisher-with-sensor-integration",level:2},{value:"Exercise 5: Launch File and System Integration",id:"exercise-5-launch-file-and-system-integration",level:2},{value:"Exercise 6: System Testing and Validation",id:"exercise-6-system-testing-and-validation",level:2},{value:"Running the Complete System",id:"running-the-complete-system",level:3},{value:"Exercise 7: Performance Optimization and Debugging",id:"exercise-7-performance-optimization-and-debugging",level:2},{value:"Optimized Implementation",id:"optimized-implementation",level:3},{value:"Exercise 8: Troubleshooting Common Issues",id:"exercise-8-troubleshooting-common-issues",level:2},{value:"Debugging Script",id:"debugging-script",level:3},{value:"Summary",id:"summary",level:2}];function c(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...r.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"44-practical-exercises---tf2-and-urdf-integration",children:"4.4: Practical Exercises - TF2 and URDF Integration"})}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"This submodule provides hands-on exercises to apply TF2 and URDF concepts in realistic robotic scenarios. You'll build complete systems that integrate both technologies, working with real sensor data, robot models, and spatial transformations."}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this submodule, you will:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Build a complete robot model with sensors using URDF"}),"\n",(0,s.jsx)(e.li,{children:"Integrate TF2 with robot state publishing"}),"\n",(0,s.jsx)(e.li,{children:"Process and transform real sensor data using TF2"}),"\n",(0,s.jsx)(e.li,{children:"Debug TF tree issues in complex robot systems"}),"\n",(0,s.jsx)(e.li,{children:"Create a complete navigation-ready robot model"}),"\n",(0,s.jsx)(e.li,{children:"Apply performance optimization techniques"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"exercise-1-building-a-complete-robot-model",children:"Exercise 1: Building a Complete Robot Model"}),"\n",(0,s.jsx)(e.h3,{id:"objective",children:"Objective"}),"\n",(0,s.jsx)(e.p,{children:"Create a complete URDF model for a mobile robot with multiple sensors and implement the supporting launch files."}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-the-package-structure",children:"Step 1: Create the Package Structure"}),"\n",(0,s.jsx)(e.p,{children:"First, create a new ROS 2 package for our robot model:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create --build-type ament_python robot_model_exercises\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-create-the-urdf-model",children:"Step 2: Create the URDF Model"}),"\n",(0,s.jsxs)(e.p,{children:["Create the file ",(0,s.jsx)(e.code,{children:"robot_model_exercises/urdf/exercise_robot.urdf.xacro"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="exercise_robot">\r\n  \r\n  \x3c!-- Properties --\x3e\r\n  <xacro:property name="M_PI" value="3.1415926535897931"/>\r\n  <xacro:property name="base_width" value="0.6"/>\r\n  <xacro:property name="base_length" value="0.8"/>\r\n  <xacro:property name="base_height" value="0.3"/>\r\n  <xacro:property name="wheel_radius" value="0.15"/>\r\n  <xacro:property name="wheel_width" value="0.08"/>\r\n  <xacro:property name="wheel_mass" value="2.0"/>\r\n  <xacro:property name="base_mass" value="50.0"/>\r\n  <xacro:property name="caster_radius" value="0.05"/>\r\n  \r\n  \x3c!-- Materials --\x3e\r\n  <material name="black">\r\n    <color rgba="0.0 0.0 0.0 1.0"/>\r\n  </material>\r\n  \r\n  <material name="blue">\r\n    <color rgba="0.0 0.0 0.8 1.0"/>\r\n  </material>\r\n  \r\n  <material name="red">\r\n    <color rgba="0.8 0.0 0.0 1.0"/>\r\n  </material>\r\n  \r\n  <material name="white">\r\n    <color rgba="1.0 1.0 1.0 1.0"/>\r\n  </material>\r\n  \r\n  \x3c!-- Base link --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="${base_mass}"/>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <inertia ixx="5.0" ixy="0.0" ixz="0.0" iyy="5.0" iyz="0.0" izz="10.0"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  \x3c!-- Base footprint --\x3e\r\n  <link name="base_footprint">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder radius="0.01" length="0.001"/>\r\n      </geometry>\r\n      <material name="white"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0.01" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="${base_width/2}" length="0.02"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.0001"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  \x3c!-- Joint: base_footprint to base_link --\x3e\r\n  <joint name="base_footprint_joint" type="fixed">\r\n    <parent link="base_footprint"/>\r\n    <child link="base_link"/>\r\n    <origin xyz="0 0 ${base_height/2}" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- Macro for wheels --\x3e\r\n  <xacro:macro name="wheel" params="prefix reflect">\r\n    <link name="${prefix}_wheel_link">\r\n      <visual>\r\n        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n        <material name="black"/>\r\n      </visual>\r\n      \r\n      <collision>\r\n        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n      </collision>\r\n      \r\n      <inertial>\r\n        <mass value="${wheel_mass}"/>\r\n        <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.2"/>\r\n      </inertial>\r\n    </link>\r\n    \r\n    <joint name="${prefix}_wheel_joint" type="continuous">\r\n      <parent link="base_link"/>\r\n      <child link="${prefix}_wheel_link"/>\r\n      <origin xyz="${base_length/2 - wheel_width/2} ${reflect * (base_width/2 + wheel_width/2)} -${base_height/2}" rpy="0 0 0"/>\r\n      <axis xyz="0 1 0"/>\r\n    </joint>\r\n  </xacro:macro>\r\n  \r\n  \x3c!-- Create wheels --\x3e\r\n  <xacro:wheel prefix="front_left" reflect="1"/>\r\n  <xacro:wheel prefix="front_right" reflect="-1"/>\r\n  <xacro:wheel prefix="rear_left" reflect="1"/>\r\n  <xacro:wheel prefix="rear_right" reflect="-1"/>\r\n  \r\n  \x3c!-- Front caster wheel --\x3e\r\n  <link name="front_caster_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="${caster_radius}"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="${caster_radius}"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="front_caster_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="front_caster_link"/>\r\n    <origin xyz="${base_length/2 - caster_radius} 0 -${base_height/2 + caster_radius}" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n  </joint>\r\n  \r\n  \x3c!-- Rear caster wheel --\x3e\r\n  <link name="rear_caster_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="${caster_radius}"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="${caster_radius}"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="rear_caster_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="rear_caster_link"/>\r\n    <origin xyz="-${base_length/2 + caster_radius} 0 -${base_height/2 + caster_radius}" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n  </joint>\r\n  \r\n  \x3c!-- Sensor mount plate --\x3e\r\n  <link name="sensor_mount_plate">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.2 0.02"/>\r\n      </geometry>\r\n      <material name="white"/>\r\n    </visual>\r\n    \r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.002"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="sensor_mount_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="sensor_mount_plate"/>\r\n    <origin xyz="${base_length/2 - 0.1} 0 ${base_height/2 + 0.01}" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- RGB-D Camera --\x3e\r\n  <link name="camera_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.05 0.1 0.03"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.05 0.1 0.03"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="camera_joint" type="fixed">\r\n    <parent link="sensor_mount_plate"/>\r\n    <child link="camera_link"/>\r\n    <origin xyz="0.025 0 0.025" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- LIDAR --\x3e\r\n  <link name="lidar_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.05"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.3"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="lidar_joint" type="fixed">\r\n    <parent link="sensor_mount_plate"/>\r\n    <child link="lidar_link"/>\r\n    <origin xyz="0.05 0 0.05" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- IMU --\x3e\r\n  <link name="imu_link">\r\n    <inertial>\r\n      <mass value="0.01"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="imu_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="imu_link"/>\r\n    <origin xyz="0 0 ${base_height/4}" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-update-package-files",children:"Step 3: Update Package Files"}),"\n",(0,s.jsxs)(e.p,{children:["Update ",(0,s.jsx)(e.code,{children:"robot_model_exercises/package.xml"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\r\n<package format="3">\r\n  <name>robot_model_exercises</name>\r\n  <version>0.1.0</version>\r\n  <description>Practical exercises for TF2 and URDF integration</description>\r\n  <maintainer email="user@example.com">User</maintainer>\r\n  <license>Apache-2.0</license>\r\n\r\n  <depend>rclpy</depend>\r\n  <depend>std_msgs</depend>\r\n  <depend>geometry_msgs</depend>\r\n  <depend>sensor_msgs</depend>\r\n  <depend>nav_msgs</depend>\r\n  <depend>tf2_ros</depend>\r\n  <depend>tf2_geometry_msgs</depend>\r\n  <depend>tf_transformations</depend>\r\n\r\n  <buildtool_depend>ament_python</buildtool_depend>\r\n\r\n  <test_depend>ament_copyright</test_depend>\r\n  <test_depend>ament_flake8</test_depend>\r\n  <test_depend>ament_pep257</test_depend>\r\n  <test_depend>python3-pytest</test_depend>\r\n\r\n  <export>\r\n    <build_type>ament_python</build_type>\r\n  </export>\r\n</package>\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Update ",(0,s.jsx)(e.code,{children:"robot_model_exercises/setup.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from setuptools import setup\r\nfrom glob import glob\r\nimport os\r\n\r\npackage_name = 'robot_model_exercises'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.1.0',\r\n    packages=[package_name],\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n        # Include URDF files\r\n        (os.path.join('share', package_name, 'urdf'), glob('urdf/*.urdf.xacro')),\r\n        # Include launch files\r\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='User',\r\n    maintainer_email='user@example.com',\r\n    description='Practical exercises for TF2 and URDF integration',\r\n    license='Apache-2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'sensor_transformer = robot_model_exercises.sensor_transformer:main',\r\n            'tf_visualizer = robot_model_exercises.tf_visualizer:main',\r\n            'robot_state_publisher = robot_model_exercises.robot_state_publisher:main',\r\n        ],\r\n    },\r\n)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-2-sensor-data-transformation",children:"Exercise 2: Sensor Data Transformation"}),"\n",(0,s.jsx)(e.h3,{id:"objective-1",children:"Objective"}),"\n",(0,s.jsx)(e.p,{children:"Create a node that subscribes to sensor data and transforms it between coordinate frames using TF2."}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"robot_model_exercises/robot_model_exercises/sensor_transformer.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, PointCloud2\r\nfrom geometry_msgs.msg import PointStamped, TransformStamped\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom tf2_ros import TransformException\r\nfrom tf2_geometry_msgs import do_transform_points\r\nfrom rclpy.qos import QoSProfile\r\nimport numpy as np\r\nimport math\r\nfrom sensor_msgs_py import point_cloud2\r\nfrom sensor_msgs.msg import PointField\r\n\r\nclass SensorTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_transformer')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        \r\n        # Create a transform listener\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create QoS profile\r\n        qos = QoSProfile(depth=10)\r\n        \r\n        # Subscribe to laser scan\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, 'scan', self.scan_callback, qos)\r\n        \r\n        # Subscribe to point cloud (if available)\r\n        self.pc_sub = self.create_subscription(\r\n            PointCloud2, 'point_cloud', self.point_cloud_callback, qos)\r\n        \r\n        # Publishers for transformed data\r\n        self.transformed_scan_pub = self.create_publisher(\r\n            LaserScan, 'scan_in_base_link', qos)\r\n        self.transformed_point_pub = self.create_publisher(\r\n            PointStamped, 'transformed_point', qos)\r\n        \r\n        # Timer for periodic frame checking\r\n        self.timer = self.create_timer(1.0, self.check_frames)\r\n        \r\n        self.get_logger().info('Sensor transformer node started')\r\n\r\n    def scan_callback(self, msg):\r\n        \"\"\"Transform laser scan from sensor frame to base_link frame\"\"\"\r\n        try:\r\n            # Look up transform from lidar frame to base_link\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link',      # Target frame\r\n                msg.header.frame_id,  # Source frame\r\n                msg.header.stamp,     # Time of the scan\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n            \r\n            # Transform the laser scan\r\n            transformed_scan = LaserScan()\r\n            transformed_scan.header.stamp = self.get_clock().now().to_msg()\r\n            transformed_scan.header.frame_id = 'base_link'\r\n            transformed_scan.angle_min = msg.angle_min\r\n            transformed_scan.angle_max = msg.angle_max\r\n            transformed_scan.angle_increment = msg.angle_increment\r\n            transformed_scan.time_increment = msg.time_increment\r\n            transformed_scan.scan_time = msg.scan_time\r\n            transformed_scan.range_min = msg.range_min\r\n            transformed_scan.range_max = msg.range_max\r\n            transformed_scan.ranges = msg.ranges\r\n            transformed_scan.intensities = msg.intensities if msg.intensities else []\r\n            \r\n            # Publish the transformed scan\r\n            self.transformed_scan_pub.publish(transformed_scan)\r\n            \r\n            # Log the transformation\r\n            self.get_logger().info(\r\n                f'Transformed scan from {msg.header.frame_id} to base_link')\r\n            \r\n        except TransformException as ex:\r\n            self.get_logger().warn(f'Could not transform scan: {ex}')\r\n\r\n    def point_cloud_callback(self, msg):\r\n        \"\"\"Transform point cloud from sensor frame to base_link frame\"\"\"\r\n        try:\r\n            # Look up transform\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link',\r\n                msg.header.frame_id,\r\n                msg.header.stamp,\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n            \r\n            # Extract points from PointCloud2\r\n            points = []\r\n            for point in point_cloud2.read_points(msg, field_names=(\"x\", \"y\", \"z\"), skip_nans=True):\r\n                points.append([point[0], point[1], point[2], 1.0])  # Format for transformation\r\n            \r\n            # Convert to homogeneous coordinates if needed\r\n            points_array = np.array(points).T\r\n            \r\n            # Create transformation matrix from TF transform\r\n            t = transform.transform.translation\r\n            r = transform.transform.rotation\r\n            \r\n            # Create 4x4 transformation matrix\r\n            transform_matrix = np.eye(4)\r\n            # Translation\r\n            transform_matrix[0, 3] = t.x\r\n            transform_matrix[1, 3] = t.y\r\n            transform_matrix[2, 3] = t.z\r\n            \r\n            # Rotation (quaternion to matrix)\r\n            qw, qx, qy, qz = r.w, r.x, r.y, r.z\r\n            # Convert quaternion to rotation matrix\r\n            transform_matrix[0, 0] = 1 - 2*(qy*qy + qz*qz)\r\n            transform_matrix[0, 1] = 2*(qx*qy - qw*qz)\r\n            transform_matrix[0, 2] = 2*(qx*qz + qw*qy)\r\n            transform_matrix[1, 0] = 2*(qx*qy + qw*qz)\r\n            transform_matrix[1, 1] = 1 - 2*(qx*qx + qz*qz)\r\n            transform_matrix[1, 2] = 2*(qy*qz - qw*qx)\r\n            transform_matrix[2, 0] = 2*(qx*qz - qw*qy)\r\n            transform_matrix[2, 1] = 2*(qy*qz + qw*qx)\r\n            transform_matrix[2, 2] = 1 - 2*(qx*qx + qy*qy)\r\n            \r\n            # Transform points\r\n            transformed_points = transform_matrix @ points_array\r\n            \r\n            # Log transformation result\r\n            self.get_logger().info(\r\n                f'Transformed point cloud with {len(points)} points from {msg.header.frame_id} to base_link')\r\n            \r\n        except TransformException as ex:\r\n            self.get_logger().warn(f'Could not transform point cloud: {ex}')\r\n        except Exception as e:\r\n            self.get_logger().warn(f'Point cloud transformation failed: {e}')\r\n\r\n    def check_frames(self):\r\n        \"\"\"Periodically check if all required frames exist\"\"\"\r\n        required_frames = [\r\n            'base_link', 'base_footprint', 'lidar_link', \r\n            'camera_link', 'imu_link'\r\n        ]\r\n        \r\n        missing_frames = []\r\n        for frame in required_frames:\r\n            try:\r\n                # Check if frame exists by looking up transform to itself in the past\r\n                self.tf_buffer.lookup_transform(frame, frame, rclpy.time.Time(), \r\n                                               timeout=rclpy.duration.Duration(seconds=0.1))\r\n            except:\r\n                missing_frames.append(frame)\r\n        \r\n        if missing_frames:\r\n            self.get_logger().warn(f'Missing frames: {missing_frames}')\r\n        else:\r\n            self.get_logger().info('All required frames are available')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SensorTransformer()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down sensor transformer...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-3-tf-visualization-and-analysis",children:"Exercise 3: TF Visualization and Analysis"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"robot_model_exercises/robot_model_exercises/tf_visualizer.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nfrom geometry_msgs.msg import Point\r\nfrom tf2_ros import Buffer, TransformListener\r\nfrom tf2_ros import TransformException\r\nfrom rclpy.qos import QoSProfile\r\nimport math\r\n\r\nclass TFVisualizer(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_visualizer')\r\n        \r\n        # Create TF buffer and listener\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create publisher for visualization markers\r\n        qos = QoSProfile(depth=10)\r\n        self.marker_pub = self.create_publisher(MarkerArray, 'tf_visualization_markers', qos)\r\n        \r\n        # Timer to periodically update visualization\r\n        self.timer = self.create_timer(0.5, self.update_visualization)\r\n        \r\n        self.get_logger().info('TF Visualizer started')\r\n\r\n    def update_visualization(self):\r\n        \"\"\"Update visualization of TF tree\"\"\"\r\n        try:\r\n            # Get all available frames\r\n            all_frames = self.tf_buffer.all_frames_as_string()\r\n            \r\n            # Create marker array\r\n            marker_array = MarkerArray()\r\n            \r\n            # Create a marker for each transform\r\n            frame_names = [name.split(' ')[0] for name in all_frames.split('\\n') if name]\r\n            frame_names = [name for name in frame_names if name]  # Remove empty strings\r\n            \r\n            # Create axes for each frame\r\n            for i, frame in enumerate(frame_names):\r\n                try:\r\n                    # Get transform from base_link to this frame\r\n                    t = self.tf_buffer.lookup_transform(\r\n                        'base_link', frame, rclpy.time.Time())\r\n                    \r\n                    # Create axis markers\r\n                    self.add_frame_axes(marker_array, t, frame, i)\r\n                except TransformException:\r\n                    # If can't transform to base_link, skip this frame\r\n                    continue\r\n            \r\n            # Publish the marker array\r\n            self.marker_pub.publish(marker_array)\r\n            \r\n        except Exception as e:\r\n            self.get_logger().warn(f'Error updating visualization: {e}')\r\n\r\n    def add_frame_axes(self, marker_array, transform, frame_name, frame_id):\r\n        \"\"\"Add coordinate axes visualization for a frame\"\"\"\r\n        # X-axis (red)\r\n        x_axis_marker = Marker()\r\n        x_axis_marker.header.frame_id = 'base_link'\r\n        x_axis_marker.header.stamp = self.get_clock().now().to_msg()\r\n        x_axis_marker.ns = f\"x_axis_{frame_name}\"\r\n        x_axis_marker.id = frame_id * 3\r\n        x_axis_marker.type = Marker.ARROW\r\n        x_axis_marker.action = Marker.ADD\r\n        \r\n        # Set start point to transform origin\r\n        start_point = Point()\r\n        start_point.x = transform.transform.translation.x\r\n        start_point.y = transform.transform.translation.y\r\n        start_point.z = transform.transform.translation.z\r\n        \r\n        # Set end point to be along x-axis\r\n        end_point = Point()\r\n        end_point.x = start_point.x + 0.1  # 10cm along x-axis\r\n        end_point.y = start_point.y\r\n        end_point.z = start_point.z\r\n        \r\n        x_axis_marker.points = [start_point, end_point]\r\n        x_axis_marker.scale.x = 0.01  # Shaft diameter\r\n        x_axis_marker.scale.y = 0.02  # Head diameter\r\n        x_axis_marker.color.r = 1.0\r\n        x_axis_marker.color.g = 0.0\r\n        x_axis_marker.color.b = 0.0\r\n        x_axis_marker.color.a = 1.0\r\n        \r\n        marker_array.markers.append(x_axis_marker)\r\n        \r\n        # Y-axis (green)\r\n        y_axis_marker = Marker()\r\n        y_axis_marker.header.frame_id = 'base_link'\r\n        y_axis_marker.header.stamp = self.get_clock().now().to_msg()\r\n        y_axis_marker.ns = f\"y_axis_{frame_name}\"\r\n        y_axis_marker.id = frame_id * 3 + 1\r\n        y_axis_marker.type = Marker.ARROW\r\n        y_axis_marker.action = Marker.ADD\r\n        \r\n        start_point = Point()\r\n        start_point.x = transform.transform.translation.x\r\n        start_point.y = transform.transform.translation.y\r\n        start_point.z = transform.transform.translation.z\r\n        \r\n        end_point = Point()\r\n        end_point.x = start_point.x\r\n        end_point.y = start_point.y + 0.1  # 10cm along y-axis\r\n        end_point.z = start_point.z\r\n        \r\n        y_axis_marker.points = [start_point, end_point]\r\n        y_axis_marker.scale.x = 0.01\r\n        y_axis_marker.scale.y = 0.02\r\n        y_axis_marker.color.r = 0.0\r\n        y_axis_marker.color.g = 1.0\r\n        y_axis_marker.color.b = 0.0\r\n        y_axis_marker.color.a = 1.0\r\n        \r\n        marker_array.markers.append(y_axis_marker)\r\n        \r\n        # Z-axis (blue)\r\n        z_axis_marker = Marker()\r\n        z_axis_marker.header.frame_id = 'base_link'\r\n        z_axis_marker.header.stamp = self.get_clock().now().to_msg()\r\n        z_axis_marker.ns = f\"z_axis_{frame_name}\"\r\n        z_axis_marker.id = frame_id * 3 + 2\r\n        z_axis_marker.type = Marker.ARROW\r\n        z_axis_marker.action = Marker.ADD\r\n        \r\n        start_point = Point()\r\n        start_point.x = transform.transform.translation.x\r\n        start_point.y = transform.transform.translation.y\r\n        start_point.z = transform.transform.translation.z\r\n        \r\n        end_point = Point()\r\n        end_point.x = start_point.x\r\n        end_point.y = start_point.y\r\n        end_point.z = start_point.z + 0.1  # 10cm along z-axis\r\n        \r\n        z_axis_marker.points = [start_point, end_point]\r\n        z_axis_marker.scale.x = 0.01\r\n        z_axis_marker.scale.y = 0.02\r\n        z_axis_marker.color.r = 0.0\r\n        z_axis_marker.color.g = 0.0\r\n        z_axis_marker.color.b = 1.0\r\n        z_axis_marker.color.a = 1.0\r\n        \r\n        marker_array.markers.append(z_axis_marker)\r\n\r\n    def get_tf_tree_info(self):\r\n        \"\"\"Get information about the TF tree structure\"\"\"\r\n        try:\r\n            tree_info = self.tf_buffer.all_frames_as_yaml()\r\n            self.get_logger().info(f'TF Tree:\\n{tree_info}')\r\n            \r\n            # Identify root frame\r\n            all_frames = self.tf_buffer.all_frames_as_string()\r\n            self.get_logger().info(f'Available frames: {all_frames}')\r\n            \r\n        except Exception as e:\r\n            self.get_logger().error(f'Error getting TF tree info: {e}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TFVisualizer()\r\n    \r\n    # Run tree info once at startup\r\n    node.get_tf_tree_info()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down TF visualizer...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-4-robot-state-publisher-with-sensor-integration",children:"Exercise 4: Robot State Publisher with Sensor Integration"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"robot_model_exercises/robot_model_exercises/robot_state_publisher.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom nav_msgs.msg import Odometry\r\nfrom geometry_msgs.msg import TransformStamped\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom std_msgs.msg import Header\r\nfrom rclpy.qos import QoSProfile\r\nimport math\r\nimport numpy as np\r\n\r\nclass ExerciseRobotStatePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('exercise_robot_state_publisher')\r\n        \r\n        # Create transform broadcaster\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n        \r\n        # Create QoS profile\r\n        qos = QoSProfile(depth=10)\r\n        \r\n        # Subscribe to joint states (from simulated or real robot)\r\n        self.joint_sub = self.create_subscription(\r\n            JointState, 'joint_states', self.joint_callback, qos)\r\n        \r\n        # Subscribe to odometry (if available)\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, 'odom', self.odom_callback, qos)\r\n        \r\n        # Publishers for joint states (if needed for simulation)\r\n        self.joint_pub = self.create_publisher(JointState, 'joint_states', qos)\r\n        \r\n        # Timer for publishing state\r\n        self.timer = self.create_timer(0.02, self.publish_robot_states)  # 50 Hz\r\n        \r\n        # Robot state variables\r\n        self.wheel_positions = {\r\n            'front_left_wheel_joint': 0.0,\r\n            'front_right_wheel_joint': 0.0,\r\n            'rear_left_wheel_joint': 0.0,\r\n            'rear_right_wheel_joint': 0.0\r\n        }\r\n        \r\n        self.caster_positions = {\r\n            'front_caster_joint': 0.0,\r\n            'rear_caster_joint': 0.0\r\n        }\r\n        \r\n        # Robot pose from odometry\r\n        self.x = 0.0\r\n        self.y = 0.0\r\n        self.theta = 0.0\r\n        \r\n        # Simulate robot movement\r\n        self.sim_time = 0.0\r\n        \r\n        self.get_logger().info('Exercise Robot State Publisher started')\r\n\r\n    def joint_callback(self, msg):\r\n        \"\"\"Update joint positions from joint state messages\"\"\"\r\n        for i, name in enumerate(msg.name):\r\n            if name in self.wheel_positions:\r\n                self.wheel_positions[name] = msg.position[i]\r\n            elif name in self.caster_positions:\r\n                self.caster_positions[name] = msg.position[i]\r\n\r\n    def odom_callback(self, msg):\r\n        \"\"\"Update robot pose from odometry\"\"\"\r\n        self.x = msg.pose.pose.position.x\r\n        self.y = msg.pose.pose.position.y\r\n        \r\n        # Convert quaternion to yaw\r\n        q = msg.pose.pose.orientation\r\n        siny_cosp = 2 * (q.w * q.z + q.x * q.y)\r\n        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)\r\n        self.theta = math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def publish_robot_states(self):\r\n        \"\"\"Publish robot states including transforms\"\"\"\r\n        # Simulate wheel motion\r\n        self.sim_time += 0.02  # Increment simulation time\r\n        \r\n        # Update wheel positions based on simulated motion\r\n        wheel_velocity = 1.0  # rad/s\r\n        for joint_name in self.wheel_positions:\r\n            self.wheel_positions[joint_name] += wheel_velocity * 0.02\r\n            if 'right' in joint_name:  # Right wheels rotate opposite for forward motion\r\n                self.wheel_positions[joint_name] -= 2 * wheel_velocity * 0.02\r\n        \r\n        # Update caster positions\r\n        for joint_name in self.caster_positions:\r\n            self.caster_positions[joint_name] = math.sin(self.sim_time) * 0.5  # Oscillating\r\n        \r\n        # Move robot in a square pattern\r\n        linear_vel = 0.5  # m/s\r\n        current_seg = int(self.sim_time / 5) % 4  # 5 seconds per side\r\n        seg_time = self.sim_time % 5\r\n        \r\n        if current_seg == 0:  # Moving in +X direction\r\n            self.x += linear_vel * 0.02\r\n        elif current_seg == 1:  # Moving in +Y direction\r\n            self.y += linear_vel * 0.02\r\n        elif current_seg == 2:  # Moving in -X direction\r\n            self.x -= linear_vel * 0.02\r\n        else:  # Moving in -Y direction\r\n            self.y -= linear_vel * 0.02\r\n        \r\n        # Publish joint states (if needed for other nodes)\r\n        self.publish_joint_states()\r\n        \r\n        # Publish transforms\r\n        self.publish_transforms()\r\n\r\n    def publish_joint_states(self):\r\n        \"\"\"Publish joint state messages\"\"\"\r\n        msg = JointState()\r\n        msg.name = []\r\n        msg.position = []\r\n        msg.velocity = []\r\n        msg.effort = []\r\n        \r\n        msg.header = Header()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = 'joint_states'\r\n        \r\n        # Add wheel joints\r\n        for joint_name, position in self.wheel_positions.items():\r\n            msg.name.append(joint_name)\r\n            msg.position.append(position)\r\n            msg.velocity.append(1.0)  # Simulated velocity\r\n            msg.effort.append(0.0)\r\n        \r\n        # Add caster joints\r\n        for joint_name, position in self.caster_positions.items():\r\n            msg.name.append(joint_name)\r\n            msg.position.append(position)\r\n            msg.velocity.append(0.5)  # Simulated velocity\r\n            msg.effort.append(0.0)\r\n        \r\n        self.joint_pub.publish(msg)\r\n\r\n    def publish_transforms(self):\r\n        \"\"\"Publish all static and dynamic transforms\"\"\"\r\n        # Transform from odom to base_footprint (simulating odometry)\r\n        t = TransformStamped()\r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = 'odom'\r\n        t.child_frame_id = 'base_footprint'\r\n        \r\n        t.transform.translation.x = self.x\r\n        t.transform.translation.y = self.y\r\n        t.transform.translation.z = 0.0\r\n        \r\n        # Convert theta to quaternion\r\n        from tf_transformations import quaternion_from_euler\r\n        q = quaternion_from_euler(0, 0, self.theta)\r\n        t.transform.rotation.x = q[0]\r\n        t.transform.rotation.y = q[1]\r\n        t.transform.rotation.z = q[2]\r\n        t.transform.rotation.w = q[3]\r\n        \r\n        self.tf_broadcaster.sendTransform(t)\r\n        \r\n        # Transform from base_footprint to base_link (fixed offset)\r\n        t2 = TransformStamped()\r\n        t2.header.stamp = self.get_clock().now().to_msg()\r\n        t2.header.frame_id = 'base_footprint'\r\n        t2.child_frame_id = 'base_link'\r\n        \r\n        t2.transform.translation.x = 0.0\r\n        t2.transform.translation.y = 0.0\r\n        t2.transform.translation.z = 0.15  # base_height/2 = 0.3/2\r\n        \r\n        t2.transform.rotation.x = 0.0\r\n        t2.transform.rotation.y = 0.0\r\n        t2.transform.rotation.z = 0.0\r\n        t2.transform.rotation.w = 1.0\r\n        \r\n        self.tf_broadcaster.sendTransform(t2)\r\n        \r\n        # Transform for each wheel (dynamic based on joint positions)\r\n        wheel_transforms = [\r\n            ('front_left_wheel_joint', 'base_link', 'front_left_wheel_link', 0.35, 0.35, -0.15),\r\n            ('front_right_wheel_joint', 'base_link', 'front_right_wheel_link', 0.35, -0.35, -0.15),\r\n            ('rear_left_wheel_joint', 'base_link', 'rear_left_wheel_link', -0.35, 0.35, -0.15),\r\n            ('rear_right_wheel_joint', 'base_link', 'rear_right_wheel_link', -0.35, -0.35, -0.15),\r\n        ]\r\n        \r\n        for joint_name, parent_frame, child_frame, x, y, z in wheel_transforms:\r\n            t = TransformStamped()\r\n            t.header.stamp = self.get_clock().now().to_msg()\r\n            t.header.frame_id = parent_frame\r\n            t.child_frame_id = child_frame\r\n            \r\n            t.transform.translation.x = x\r\n            t.transform.translation.y = y\r\n            t.transform.translation.z = z\r\n            \r\n            # Rotate wheel based on joint position\r\n            q_wheel = quaternion_from_euler(0, 0, self.wheel_positions[joint_name])\r\n            t.transform.rotation.x = q_wheel[0]\r\n            t.transform.rotation.y = q_wheel[1]\r\n            t.transform.rotation.z = q_wheel[2]\r\n            t.transform.rotation.w = q_wheel[3]\r\n            \r\n            self.tf_broadcaster.sendTransform(t)\r\n        \r\n        # Transform for caster wheels\r\n        caster_transforms = [\r\n            ('front_caster_joint', 'base_link', 'front_caster_link', 0.25, 0.0, -0.15),\r\n            ('rear_caster_joint', 'base_link', 'rear_caster_link', -0.25, 0.0, -0.15),\r\n        ]\r\n        \r\n        for joint_name, parent_frame, child_frame, x, y, z in caster_transforms:\r\n            t = TransformStamped()\r\n            t.header.stamp = self.get_clock().now().to_msg()\r\n            t.header.frame_id = parent_frame\r\n            t.child_frame_id = child_frame\r\n            \r\n            t.transform.translation.x = x\r\n            t.transform.translation.y = y\r\n            t.transform.translation.z = z\r\n            \r\n            # Rotate caster based on joint position\r\n            q_caster = quaternion_from_euler(\r\n                math.sin(self.caster_positions[joint_name]) * 0.1,\r\n                math.cos(self.caster_positions[joint_name]) * 0.1,\r\n                self.caster_positions[joint_name]\r\n            )\r\n            t.transform.rotation.x = q_caster[0]\r\n            t.transform.rotation.y = q_caster[1]\r\n            t.transform.rotation.z = q_caster[2]\r\n            t.transform.rotation.w = q_caster[3]\r\n            \r\n            self.tf_broadcaster.sendTransform(t)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ExerciseRobotStatePublisher()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down robot state publisher...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-5-launch-file-and-system-integration",children:"Exercise 5: Launch File and System Integration"}),"\n",(0,s.jsxs)(e.p,{children:["Create the launch file ",(0,s.jsx)(e.code,{children:"robot_model_exercises/launch/exercise_system_launch.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import Command, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare arguments\r\n    declared_arguments = []\r\n    declared_arguments.append(\r\n        DeclareLaunchArgument(\r\n            'description_file',\r\n            default_value='exercise_robot.urdf.xacro',\r\n            description='URDF/XACRO description file with the robot'\r\n        )\r\n    )\r\n\r\n    # Get URDF via xacro\r\n    robot_description_content = Command(\r\n        [\r\n            PathJoinSubstitution([FindPackageShare(\"robot_model_exercises\"), \"urdf\", \"exercise_robot.urdf.xacro\"])\r\n        ]\r\n    )\r\n    robot_description = {\"robot_description\": robot_description_content}\r\n\r\n    # Robot State Publisher (from ROS2)\r\n    robot_state_publisher_node = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        output='both',\r\n        parameters=[robot_description]\r\n    )\r\n\r\n    # Exercise Robot State Publisher (custom node for dynamic transforms)\r\n    exercise_robot_state_publisher_node = Node(\r\n        package='robot_model_exercises',\r\n        executable='exercise_robot_state_publisher',\r\n        name='exercise_robot_state_publisher',\r\n        output='both'\r\n    )\r\n\r\n    # Sensor Transformer\r\n    sensor_transformer_node = Node(\r\n        package='robot_model_exercises',\r\n        executable='sensor_transformer',\r\n        name='sensor_transformer',\r\n        output='both'\r\n    )\r\n\r\n    # TF Visualizer\r\n    tf_visualizer_node = Node(\r\n        package='robot_model_exercises',\r\n        executable='tf_visualizer',\r\n        name='tf_visualizer',\r\n        output='both'\r\n    )\r\n\r\n    return LaunchDescription(\r\n        declared_arguments + [\r\n            robot_state_publisher_node,\r\n            exercise_robot_state_publisher_node,\r\n            sensor_transformer_node,\r\n            tf_visualizer_node,\r\n        ]\r\n    )\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-6-system-testing-and-validation",children:"Exercise 6: System Testing and Validation"}),"\n",(0,s.jsx)(e.h3,{id:"running-the-complete-system",children:"Running the Complete System"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Build the package:"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\r\ncolcon build --packages-select robot_model_exercises\r\nsource install/setup.bash\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Launch the complete system:"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 launch robot_model_exercises exercise_system_launch.py\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Monitor the TF tree:"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# View TF tree\r\nros2 run tf2_tools view_frames\r\n\r\n# Monitor TF transforms\r\nros2 run tf2_ros tf2_monitor\r\n\r\n# Echo specific transforms\r\nros2 run tf2_ros tf2_echo base_link lidar_link\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"4",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Visualize in RViz:"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 run rviz2 rviz2\n"})}),"\n",(0,s.jsx)(e.p,{children:"In RViz:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:'Add a RobotModel display and set "Robot Description" to "robot_description"'}),"\n",(0,s.jsx)(e.li,{children:"Add a TF display to visualize all transforms"}),"\n",(0,s.jsx)(e.li,{children:"Add a MarkerArray display to see the TF visualization from our node"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"exercise-7-performance-optimization-and-debugging",children:"Exercise 7: Performance Optimization and Debugging"}),"\n",(0,s.jsx)(e.h3,{id:"optimized-implementation",children:"Optimized Implementation"}),"\n",(0,s.jsx)(e.p,{children:"Create an optimized version with caching and performance considerations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# robot_model_exercises/robot_model_exercises/optimized_sensor_transformer.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom geometry_msgs.msg import PointStamped\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom tf2_ros import TransformException\r\nfrom rclpy.qos import QoSProfile\r\nimport time\r\nfrom collections import defaultdict\r\n\r\nclass OptimizedSensorTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('optimized_sensor_transformer')\r\n        \r\n        # Create a transform buffer with cache\r\n        self.tf_buffer = Buffer(\r\n            cache_time=rclpy.duration.Duration(seconds=10.0))  # 10s cache\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create QoS profile\r\n        qos = QoSProfile(depth=5)  # Reduce depth for performance\r\n        \r\n        # Subscribe to laser scan\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, 'scan', self.scan_callback, qos)\r\n        \r\n        # Publisher for transformed data\r\n        self.transformed_scan_pub = self.create_publisher(\r\n            LaserScan, 'scan_in_base_link', qos)\r\n        \r\n        # Cache for transforms that don't change frequently\r\n        self.transform_cache = {}\r\n        self.cache_timeout = 0.1  # 100ms cache timeout\r\n        \r\n        # Statistics\r\n        self.transform_count = 0\r\n        self.cache_hits = 0\r\n        \r\n        # Timer for performance statistics\r\n        self.stats_timer = self.create_timer(5.0, self.print_stats)\r\n        \r\n        self.get_logger().info('Optimized Sensor Transformer started')\r\n\r\n    def scan_callback(self, msg):\r\n        \"\"\"Transform laser scan from sensor frame to base_link frame with optimization\"\"\"\r\n        start_time = time.time()\r\n        \r\n        try:\r\n            # Check cache first\r\n            cache_key = f\"{msg.header.frame_id}_to_base_link\"\r\n            \r\n            if cache_key in self.transform_cache:\r\n                cached_transform, timestamp = self.transform_cache[cache_key]\r\n                current_time = self.get_clock().now().nanoseconds / 1e9\r\n                \r\n                if current_time - timestamp < self.cache_timeout:\r\n                    self.cache_hits += 1\r\n                    transform = cached_transform\r\n                else:\r\n                    # Cache expired, get fresh transform\r\n                    transform = self.tf_buffer.lookup_transform(\r\n                        'base_link', msg.header.frame_id, msg.header.stamp,\r\n                        timeout=rclpy.duration.Duration(seconds=0.5))\r\n                    # Update cache\r\n                    self.transform_cache[cache_key] = (transform, current_time)\r\n            else:\r\n                # No cache entry, get fresh transform\r\n                transform = self.tf_buffer.lookup_transform(\r\n                    'base_link', msg.header.frame_id, msg.header.stamp,\r\n                    timeout=rclpy.duration.Duration(seconds=0.5))\r\n                # Add to cache\r\n                current_time = self.get_clock().now().nanoseconds / 1e9\r\n                self.transform_cache[cache_key] = (transform, current_time)\r\n            \r\n            # Transform the laser scan (simplified - in real implementation, \r\n            # you'd transform each point)\r\n            transformed_scan = msg\r\n            transformed_scan.header.frame_id = 'base_link'\r\n            self.transformed_scan_pub.publish(transformed_scan)\r\n            \r\n            self.transform_count += 1\r\n            \r\n            # Log performance info periodically\r\n            if self.transform_count % 100 == 0:\r\n                end_time = time.time()\r\n                self.get_logger().info(\r\n                    f'Transform performance: {(end_time - start_time)*1000:.2f}ms, '\r\n                    f'Cache hit rate: {self.cache_hits/max(1, self.transform_count):.2%}')\r\n        \r\n        except TransformException as ex:\r\n            self.get_logger().warn(f'Could not transform scan: {ex}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Unexpected error in scan callback: {e}')\r\n\r\n    def print_stats(self):\r\n        \"\"\"Print performance statistics\"\"\"\r\n        cache_hit_rate = self.cache_hits / max(1, self.transform_count) if self.transform_count > 0 else 0\r\n        self.get_logger().info(\r\n            f'TF Performance Stats - Transforms: {self.transform_count}, '\r\n            f'Cache Hits: {self.cache_hits}, '\r\n            f'Cache Hit Rate: {cache_hit_rate:.2%}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = OptimizedSensorTransformer()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down optimized sensor transformer...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-8-troubleshooting-common-issues",children:"Exercise 8: Troubleshooting Common Issues"}),"\n",(0,s.jsx)(e.h3,{id:"debugging-script",children:"Debugging Script"}),"\n",(0,s.jsxs)(e.p,{children:["Create a debugging script ",(0,s.jsx)(e.code,{children:"robot_model_exercises/test/tf_debugger.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import Buffer, TransformListener\r\nfrom std_msgs.msg import String\r\nfrom rclpy.qos import QoSProfile\r\n\r\nclass TFDebugger(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_debugger')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Publisher for debug messages\r\n        qos = QoSProfile(depth=10)\r\n        self.debug_pub = self.create_publisher(String, 'tf_debug_output', qos)\r\n        \r\n        # Timer to run debug checks\r\n        self.timer = self.create_timer(2.0, self.run_debug_checks)\r\n        \r\n        self.get_logger().info('TF Debugger started')\r\n\r\n    def run_debug_checks(self):\r\n        \"\"\"Run various TF-related diagnostic checks\"\"\"\r\n        self.get_logger().info('--- TF Debug Report ---')\r\n        \r\n        # Check 1: List all available frames\r\n        try:\r\n            frames_yaml = self.tf_buffer.all_frames_as_yaml()\r\n            self.get_logger().info(f'Available frames:\\n{frames_yaml}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error getting frames: {e}')\r\n        \r\n        # Check 2: Validate common transforms\r\n        common_transforms = [\r\n            ('base_link', 'base_footprint'),\r\n            ('base_link', 'lidar_link'),\r\n            ('base_link', 'camera_link'),\r\n            ('odom', 'base_footprint'),\r\n        ]\r\n        \r\n        for parent, child in common_transforms:\r\n            try:\r\n                self.tf_buffer.lookup_transform(parent, child, rclpy.time.Time())\r\n                self.get_logger().info(f'\u2713 Transform {parent} -> {child} is available')\r\n            except Exception as e:\r\n                self.get_logger().warn(f'\u2717 Transform {parent} -> {child} is NOT available: {e}')\r\n        \r\n        # Check 3: Transform latency\r\n        try:\r\n            # Get the most recent transform to check timestamp\r\n            transform = self.tf_buffer.lookup_transform('base_link', 'lidar_link', rclpy.time.Time())\r\n            stamp = transform.header.stamp\r\n            current_time = self.get_clock().now()\r\n            \r\n            latency = (current_time.nanoseconds - rclpy.time.Time.from_msg(stamp).nanoseconds) / 1e9\r\n            self.get_logger().info(f'Transform latency for base_link->lidar_link: {latency:.3f}s')\r\n        except Exception as e:\r\n            self.get_logger().warn(f'Could not check transform latency: {e}')\r\n        \r\n        # Check 4: TF tree connections\r\n        try:\r\n            # Try to find path between common frames\r\n            self.tf_buffer.lookup_transform('odom', 'lidar_link', rclpy.time.Time())\r\n            self.get_logger().info('\u2713 Full path available: odom -> lidar_link')\r\n        except Exception as e:\r\n            self.get_logger().warn(f'\u2717 No full path from odom to lidar_link: {e}')\r\n        \r\n        self.get_logger().info('--- End TF Debug Report ---')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TFDebugger()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down TF debugger...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"This practical exercise module covered:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complete robot model creation"}),": Building a sophisticated URDF model with multiple sensors and joints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor data transformation"}),": Implementing nodes that transform sensor data using TF2"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"TF visualization"}),": Creating tools to visualize and analyze the TF tree"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Performance optimization"}),": Techniques for efficient TF usage in real-time systems"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"System integration"}),": Combining all components into a complete system"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Debugging techniques"}),": Tools and methods for troubleshooting TF-related issues"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"You have now learned how to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Create complex robot models using URDF/Xacro"}),"\n",(0,s.jsx)(e.li,{children:"Integrate TF2 with robot state publishing"}),"\n",(0,s.jsx)(e.li,{children:"Transform sensor data between coordinate frames"}),"\n",(0,s.jsx)(e.li,{children:"Optimize TF performance in robotics applications"}),"\n",(0,s.jsx)(e.li,{children:"Debug common TF tree issues"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"These skills are essential for developing complex robotic applications that require accurate spatial reasoning and sensor fusion."}),"\n",(0,s.jsx)(e.p,{children:"This completes the submodules for Week 4 of Module 1 on TF2 and URDF in ROS 2."})]})}function f(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,s.jsx)(e,{...r,children:(0,s.jsx)(c,{...r})}):c(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>o});var t=n(6540);const s={},a=t.createContext(s);function i(r){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function o(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(s):r.components||s:i(r.components),t.createElement(a.Provider,{value:e},r.children)}}}]);
"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[1382],{3274:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>a,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"module-1/week-4-tf-urdf/4-3-integration-tf2-urdf","title":"4.3: Integration of TF2 and URDF in Robotic Systems","description":"Overview","source":"@site/docs/module-1/week-4-tf-urdf/4-3-integration-tf2-urdf.md","sourceDirName":"module-1/week-4-tf-urdf","slug":"/module-1/week-4-tf-urdf/4-3-integration-tf2-urdf","permalink":"/docs/module-1/week-4-tf-urdf/4-3-integration-tf2-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-1/week-4-tf-urdf/4-3-integration-tf2-urdf.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"difficulty":"beginner"},"sidebar":"tutorialSidebar","previous":{"title":"4.2: Understanding URDF (Unified Robot Description Format)","permalink":"/docs/module-1/week-4-tf-urdf/4-2-understanding-urdf"},"next":{"title":"4.4: Practical Exercises - TF2 and URDF Integration","permalink":"/docs/module-1/week-4-tf-urdf/4-4-tf2-urdf-practical-exercises"}}');var i=e(4848),o=e(8453);const a={sidebar_position:3,difficulty:"beginner"},s="4.3: Integration of TF2 and URDF in Robotic Systems",l={},m=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Understanding the TF-URDF Relationship",id:"understanding-the-tf-urdf-relationship",level:2},{value:"Static vs. Dynamic Transforms",id:"static-vs-dynamic-transforms",level:3},{value:"TF Tree Generated from URDF",id:"tf-tree-generated-from-urdf",level:3},{value:"Creating a Complete Robot Model",id:"creating-a-complete-robot-model",level:2},{value:"Complete URDF Example with All Components",id:"complete-urdf-example-with-all-components",level:3},{value:"Robot State Publisher Integration",id:"robot-state-publisher-integration",level:2},{value:"Launch Configuration",id:"launch-configuration",level:3},{value:"Implementing Joint State Publisher",id:"implementing-joint-state-publisher",level:2},{value:"Custom Joint State Publisher with TF Broadcasting",id:"custom-joint-state-publisher-with-tf-broadcasting",level:3},{value:"TF2 Integration Example",id:"tf2-integration-example",level:2},{value:"Transforming Sensor Data Using URDF Frames",id:"transforming-sensor-data-using-urdf-frames",level:3},{value:"Advanced TF2 Usage with URDF",id:"advanced-tf2-usage-with-urdf",level:2},{value:"Creating a Robot State Estimator",id:"creating-a-robot-state-estimator",level:3},{value:"TF2 and URDF Debugging",id:"tf2-and-urdf-debugging",level:2},{value:"TF Tree Visualization and Analysis",id:"tf-tree-visualization-and-analysis",level:3},{value:"Practical Exercise: Complete Robot Integration",id:"practical-exercise-complete-robot-integration",level:2},{value:"Launch File for Complete System",id:"launch-file-for-complete-system",level:3},{value:"Common Integration Issues and Solutions",id:"common-integration-issues-and-solutions",level:2},{value:"1. Frame ID Mismatch",id:"1-frame-id-mismatch",level:3},{value:"2. Time Synchronization Issues",id:"2-time-synchronization-issues",level:3},{value:"3. TF Tree Discontinuity",id:"3-tf-tree-discontinuity",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient TF Usage",id:"efficient-tf-usage",level:3},{value:"Summary",id:"summary",level:2}];function c(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"43-integration-of-tf2-and-urdf-in-robotic-systems",children:"4.3: Integration of TF2 and URDF in Robotic Systems"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This submodule explores the integration between TF2 (Transform Library) and URDF (Unified Robot Description Format) in robotic systems. We'll examine how URDF provides the static structure that TF2 uses to manage dynamic transforms, enabling complex multi-frame robotics applications."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this submodule, you will:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand how URDF and TF2 work together"}),"\n",(0,i.jsx)(n.li,{children:"Create complete robot models that generate appropriate TF trees"}),"\n",(0,i.jsx)(n.li,{children:"Use robot_state_publisher to broadcast URDF-defined transforms"}),"\n",(0,i.jsx)(n.li,{children:"Implement custom transform publishers for dynamic joints"}),"\n",(0,i.jsx)(n.li,{children:"Debug TF tree issues in URDF-based robots"}),"\n",(0,i.jsx)(n.li,{children:"Develop complex multi-frame robotic applications"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-tf-urdf-relationship",children:"Understanding the TF-URDF Relationship"}),"\n",(0,i.jsx)(n.h3,{id:"static-vs-dynamic-transforms",children:"Static vs. Dynamic Transforms"}),"\n",(0,i.jsx)(n.p,{children:"The relationship between URDF and TF2 divides transforms into two categories:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Static Transforms"}),": Defined in URDF, published once by robot_state_publisher"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Transforms"}),": Published continuously by joint_state_publisher and other nodes for moving joints"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"URDF Structure -> robot_state_publisher -> Static Transforms\r\nJoint States -> joint_state_publisher -> Dynamic Transforms\r\nBoth combined -> Complete TF Tree\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tf-tree-generated-from-urdf",children:"TF Tree Generated from URDF"}),"\n",(0,i.jsx)(n.p,{children:"When you load a URDF, a hierarchy of coordinate frames is automatically created based on the link-joint structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"base_link (root)\r\n\u251c\u2500\u2500 imu_link\r\n\u251c\u2500\u2500 left_wheel_link\r\n\u251c\u2500\u2500 right_wheel_link\r\n\u251c\u2500\u2500 camera_link\r\n\u2514\u2500\u2500 lidar_link\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each joint represents a transformation between two frames, with static joints creating fixed transforms and dynamic joints having transforms that change based on joint values."}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-complete-robot-model",children:"Creating a Complete Robot Model"}),"\n",(0,i.jsx)(n.h3,{id:"complete-urdf-example-with-all-components",children:"Complete URDF Example with All Components"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a comprehensive URDF file that includes all necessary components:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="integrated_robot">\r\n  \r\n  \x3c!-- Properties --\x3e\r\n  <xacro:property name="M_PI" value="3.1415926535897931"/>\r\n  <xacro:property name="base_width" value="0.5"/>\r\n  <xacro:property name="base_length" value="0.8"/>\r\n  <xacro:property name="base_height" value="0.2"/>\r\n  <xacro:property name="wheel_radius" value="0.1"/>\r\n  <xacro:property name="wheel_width" value="0.05"/>\r\n  <xacro:property name="wheel_mass" value="0.5"/>\r\n  <xacro:property name="base_mass" value="20.0"/>\r\n  \r\n  \x3c!-- Materials --\x3e\r\n  <material name="black">\r\n    <color rgba="0.0 0.0 0.0 1.0"/>\r\n  </material>\r\n  \r\n  <material name="blue">\r\n    <color rgba="0.0 0.0 0.8 1.0"/>\r\n  </material>\r\n  \r\n  <material name="white">\r\n    <color rgba="1.0 1.0 1.0 1.0"/>\r\n  </material>\r\n  \r\n  \x3c!-- Base link --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="${base_mass}"/>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  \x3c!-- Base footprint for 2D navigation --\x3e\r\n  <link name="base_footprint">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder radius="0.01" length="0.01"/>\r\n      </geometry>\r\n      <material name="white"/>\r\n    </visual>\r\n    \r\n    <collision>\r\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.3" length="0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    \r\n    <inertial>\r\n      <mass value="0.0001"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  \x3c!-- Joint between base footprint and base link --\x3e\r\n  <joint name="base_footprint_joint" type="fixed">\r\n    <parent link="base_footprint"/>\r\n    <child link="base_link"/>\r\n    <origin xyz="0 0 ${base_height/2}" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- Macro for wheels --\x3e\r\n  <xacro:macro name="wheel" params="prefix reflect">\r\n    <link name="${prefix}_wheel_link">\r\n      <visual>\r\n        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n        <material name="black"/>\r\n      </visual>\r\n      \r\n      <collision>\r\n        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n      </collision>\r\n      \r\n      <inertial>\r\n        <mass value="${wheel_mass}"/>\r\n        <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\r\n      </inertial>\r\n    </link>\r\n    \r\n    <joint name="${prefix}_wheel_joint" type="continuous">\r\n      <parent link="base_link"/>\r\n      <child link="${prefix}_wheel_link"/>\r\n      <origin xyz="${base_length/2 - wheel_width/2} ${reflect * base_width/2} -${base_height/2}" rpy="0 0 0"/>\r\n      <axis xyz="0 1 0"/>\r\n    </joint>\r\n  </xacro:macro>\r\n  \r\n  \x3c!-- Create wheels --\x3e\r\n  <xacro:wheel prefix="front_left" reflect="1"/>\r\n  <xacro:wheel prefix="front_right" reflect="-1"/>\r\n  <xacro:wheel prefix="rear_left" reflect="1"/>\r\n  <xacro:wheel prefix="rear_right" reflect="-1"/>\r\n  \r\n  \x3c!-- Sensor mount --\x3e\r\n  <link name="sensor_mount_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.1 0.1 0.05"/>\r\n      </geometry>\r\n      <material name="white"/>\r\n    </visual>\r\n    \r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  \x3c!-- Joint to mount sensors --\x3e\r\n  <joint name="sensor_mount_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="sensor_mount_link"/>\r\n    <origin xyz="${base_length/2 - 0.05} 0 ${base_height/2 + 0.025}" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- Camera link --\x3e\r\n  <link name="camera_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.05 0.1 0.03"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n    \r\n    <inertial>\r\n      <mass value="0.05"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="camera_joint" type="fixed">\r\n    <parent link="sensor_mount_link"/>\r\n    <child link="camera_link"/>\r\n    <origin xyz="0 0 0.025" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- LIDAR link --\x3e\r\n  <link name="lidar_link">\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.05"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n    \r\n    <inertial>\r\n      <mass value="0.2"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0002"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="lidar_joint" type="fixed">\r\n    <parent link="sensor_mount_link"/>\r\n    <child link="lidar_link"/>\r\n    <origin xyz="0.05 0 0.05" rpy="0 0 0"/>\r\n  </joint>\r\n  \r\n  \x3c!-- IMU link --\x3e\r\n  <link name="imu_link">\r\n    <inertial>\r\n      <mass value="0.01"/>\r\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\r\n    </inertial>\r\n  </link>\r\n  \r\n  <joint name="imu_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="imu_link"/>\r\n    <origin xyz="0 0 ${base_height/2 - 0.05}" rpy="0 0 0"/>\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"robot-state-publisher-integration",children:"Robot State Publisher Integration"}),"\n",(0,i.jsx)(n.h3,{id:"launch-configuration",children:"Launch Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Now let's create the launch file to properly set up the robot state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# launch/integrated_robot.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import Command, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare arguments\r\n    declared_arguments = []\r\n    declared_arguments.append(\r\n        DeclareLaunchArgument(\r\n            'description_file',\r\n            default_value='integrated_robot.urdf.xacro',\r\n            description='URDF/XACRO description file with the robot'\r\n        )\r\n    )\r\n\r\n    # Get URDF via xacro\r\n    robot_description_content = Command(\r\n        [\r\n            PathJoinSubstitution([FindPackageShare(\"my_robot_description\"), \"urdf\", \"integrated_robot.urdf.xacro\"])\r\n        ]\r\n    )\r\n    robot_description = {\"robot_description\": robot_description_content}\r\n\r\n    # Robot State Publisher\r\n    robot_state_publisher_node = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        output='both',\r\n        parameters=[robot_description]\r\n    )\r\n\r\n    # Joint State Publisher (for dynamic joints)\r\n    joint_state_publisher_node = Node(\r\n        package='joint_state_publisher',\r\n        executable='joint_state_publisher',\r\n        name='joint_state_publisher',\r\n        parameters=[{\r\n            'use_sim_time': False,\r\n            'source_list': ['joint_states']\r\n        }]\r\n    )\r\n\r\n    return LaunchDescription(\r\n        declared_arguments + [\r\n            robot_state_publisher_node,\r\n            joint_state_publisher_node,\r\n        ]\r\n    )\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-joint-state-publisher",children:"Implementing Joint State Publisher"}),"\n",(0,i.jsx)(n.h3,{id:"custom-joint-state-publisher-with-tf-broadcasting",children:"Custom Joint State Publisher with TF Broadcasting"}),"\n",(0,i.jsx)(n.p,{children:"Let's implement a node that publishes realistic joint states for our robot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# robot_integration/robot_integration/joint_state_publisher.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import Header\r\nfrom rclpy.qos import QoSProfile\r\nimport math\r\n\r\nclass IntegratedJointStatePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('integrated_joint_state_publisher')\r\n        \r\n        # Create publisher for joint states\r\n        qos_profile = QoSProfile(depth=10)\r\n        self.joint_pub = self.create_publisher(JointState, 'joint_states', qos_profile)\r\n        \r\n        # Create timer to publish joint states\r\n        self.timer = self.create_timer(0.05, self.publish_joint_states)  # 20 Hz\r\n        self.time = 0.0\r\n        \r\n        # Track which joints are continuous (wheels)\r\n        self.wheel_joints = ['front_left_wheel_joint', 'front_right_wheel_joint', \r\n                            'rear_left_wheel_joint', 'rear_right_wheel_joint']\r\n\r\n    def publish_joint_states(self):\r\n        # Create joint state message\r\n        msg = JointState()\r\n        msg.name = []\r\n        msg.position = []\r\n        msg.velocity = []\r\n        msg.effort = []\r\n        \r\n        # Set header\r\n        msg.header = Header()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = 'joint_states'\r\n        \r\n        # Add wheel joint states with simulated motion\r\n        for joint_name in self.wheel_joints:\r\n            msg.name.append(joint_name)\r\n            \r\n            # Simulate wheel rotation based on time\r\n            # In a real robot, these would come from encoders\r\n            position = self.time * 2.0  # Rotate at 2 rad/s\r\n            if 'right' in joint_name:  # Right wheels go opposite direction for forward motion\r\n                position = -position\r\n                \r\n            msg.position.append(position)\r\n            msg.velocity.append(2.0)  # Constant velocity\r\n            msg.effort.append(0.0)    # No effort in simulation\r\n        \r\n        # In a real robot, you'd also add other joints like:\r\n        # - Arm joint positions from encoders\r\n        # - Gripper positions\r\n        # - Head/swivel positions\r\n        \r\n        # Publish the message\r\n        self.joint_pub.publish(msg)\r\n        \r\n        # Update time\r\n        self.time += 0.05\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = IntegratedJointStatePublisher()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tf2-integration-example",children:"TF2 Integration Example"}),"\n",(0,i.jsx)(n.h3,{id:"transforming-sensor-data-using-urdf-frames",children:"Transforming Sensor Data Using URDF Frames"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a node that demonstrates how to use the TF tree generated from our URDF:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# robot_integration/robot_integration/sensor_transformer.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, PointCloud2\r\nfrom geometry_msgs.msg import PointStamped, TransformStamped\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom tf2_ros import TransformException\r\nfrom rclpy.qos import QoSProfile\r\nimport numpy as np\r\nimport tf_transformations\r\n\r\nclass SensorTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_transformer')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        \r\n        # Create a transform listener\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Subscribe to laser scan\r\n        qos = QoSProfile(depth=10)\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, 'scan', self.scan_callback, qos)\r\n        \r\n        # Publish transformed scan\r\n        self.transformed_scan_pub = self.create_publisher(\r\n            LaserScan, 'scan_in_base_link', qos)\r\n        \r\n        # Publish specific point transformation example\r\n        self.point_pub = self.create_publisher(\r\n            PointStamped, 'transformed_point', qos)\r\n        \r\n        self.get_logger().info('Sensor transformer node started')\r\n\r\n    def scan_callback(self, msg):\r\n        try:\r\n            # Transform the laser scan from lidar frame to base_link frame\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link',      # Target frame\r\n                msg.header.frame_id,  # Source frame\r\n                msg.header.stamp,     # Time of the scan\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n            \r\n            # In a real implementation, you would transform each range reading\r\n            # Here we just verify the transform exists and log it\r\n            self.get_logger().info(\r\n                f'Scan frame {msg.header.frame_id} to base_link - '\r\n                f'transform available at time {msg.header.stamp.sec}.{msg.header.stamp.nanosec}')\r\n            \r\n            # Create and publish a transformed version of the scan\r\n            transformed_scan = msg\r\n            transformed_scan.header.frame_id = 'base_link'\r\n            self.transformed_scan_pub.publish(transformed_scan)\r\n            \r\n        except TransformException as ex:\r\n            self.get_logger().warn(f'Could not transform scan: {ex}')\r\n\r\n    def transform_point_example(self):\r\n        \"\"\"Example of transforming a point between frames\"\"\"\r\n        try:\r\n            # Create a point in the lidar frame\r\n            point_in_lidar = PointStamped()\r\n            point_in_lidar.header.frame_id = 'lidar_link'\r\n            point_in_lidar.header.stamp = self.get_clock().now().to_msg()\r\n            point_in_lidar.point.x = 1.0  # 1 meter in front of LIDAR\r\n            point_in_lidar.point.y = 0.0\r\n            point_in_lidar.point.z = 0.0\r\n            \r\n            # Transform to base_link frame\r\n            point_in_base = self.tf_buffer.transform(\r\n                point_in_lidar,\r\n                'base_link',\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n            \r\n            # Log the result\r\n            self.get_logger().info(\r\n                f'Point transformed: ({point_in_lidar.point.x:.2f}, '\r\n                f'{point_in_lidar.point.y:.2f}, {point_in_lidar.point.z:.2f}) in '\r\n                f'{point_in_lidar.header.frame_id} -> '\r\n                f'({point_in_base.point.x:.2f}, {point_in_base.point.y:.2f}, '\r\n                f'{point_in_base.point.z:.2f}) in {point_in_base.header.frame_id}')\r\n            \r\n            # Publish the transformed point\r\n            self.point_pub.publish(point_in_base)\r\n            \r\n        except TransformException as ex:\r\n            self.get_logger().warn(f'Could not transform point: {ex}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SensorTransformer()\r\n    \r\n    # Run the point transformation example periodically\r\n    timer = node.create_timer(2.0, node.transform_point_example)\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down sensor transformer...')\r\n    finally:\r\n        timer.cancel()\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-tf2-usage-with-urdf",children:"Advanced TF2 Usage with URDF"}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-robot-state-estimator",children:"Creating a Robot State Estimator"}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates how to use TF2 with sensor data to maintain an accurate robot state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# robot_integration/robot_integration/robot_state_estimator.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom nav_msgs.msg import Odometry\r\nfrom geometry_msgs.msg import TransformStamped, Point, Pose, Quaternion\r\nfrom sensor_msgs.msg import Imu, LaserScan\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom tf2_ros import TransformException\r\nimport tf_transformations\r\nimport math\r\n\r\nclass RobotStateEstimator(Node):\r\n    def __init__(self):\r\n        super().__init__('robot_state_estimator')\r\n        \r\n        # Create transform broadcaster\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n        \r\n        # Subscribe to sensor data\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, 'imu/data', self.imu_callback, 10)\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, 'scan', self.scan_callback, 10)\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, 'odom', self.odom_callback, 10)\r\n        \r\n        # Timer to broadcast transforms\r\n        self.timer = self.create_timer(0.05, self.broadcast_transforms)  # 20 Hz\r\n        \r\n        # Robot state variables\r\n        self.x = 0.0\r\n        self.y = 0.0\r\n        self.theta = 0.0\r\n        self.linear_velocity = 0.0\r\n        self.angular_velocity = 0.0\r\n        \r\n        # Store last timestamp for velocity calculation\r\n        self.last_time = self.get_clock().now()\r\n        \r\n        self.get_logger().info('Robot state estimator started')\r\n\r\n    def imu_callback(self, msg):\r\n        # Extract orientation from IMU\r\n        self.theta = self.quaternion_to_yaw(\r\n            msg.orientation.x,\r\n            msg.orientation.y,\r\n            msg.orientation.z,\r\n            msg.orientation.w\r\n        )\r\n        \r\n        # Extract angular velocity\r\n        self.angular_velocity = msg.angular_velocity.z\r\n\r\n    def scan_callback(self, msg):\r\n        # This callback could be used for laser-based localization\r\n        # For this example, we'll just log the fact that we received a scan\r\n        pass\r\n\r\n    def odom_callback(self, msg):\r\n        # Update position from odometry\r\n        self.x = msg.pose.pose.position.x\r\n        self.y = msg.pose.pose.position.y\r\n        \r\n        # Update orientation\r\n        self.theta = self.quaternion_to_yaw(\r\n            msg.pose.pose.orientation.x,\r\n            msg.pose.pose.orientation.y,\r\n            msg.pose.pose.orientation.z,\r\n            msg.pose.pose.orientation.w\r\n        )\r\n        \r\n        # Update velocities\r\n        self.linear_velocity = msg.twist.twist.linear.x\r\n        self.angular_velocity = msg.twist.twist.angular.z\r\n\r\n    def quaternion_to_yaw(self, x, y, z, w):\r\n        \"\"\"Convert quaternion to yaw angle\"\"\"\r\n        siny_cosp = 2 * (w * z + x * y)\r\n        cosy_cosp = 1 - 2 * (y * y + z * z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def broadcast_transforms(self):\r\n        # Broadcast the transform from odom to base_footprint\r\n        t = TransformStamped()\r\n        \r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = 'odom'\r\n        t.child_frame_id = 'base_footprint'\r\n        \r\n        t.transform.translation.x = self.x\r\n        t.transform.translation.y = self.y\r\n        t.transform.translation.z = 0.0\r\n        \r\n        # Convert theta to quaternion\r\n        q = tf_transformations.quaternion_from_euler(0, 0, self.theta)\r\n        t.transform.rotation.x = q[0]\r\n        t.transform.rotation.y = q[1]\r\n        t.transform.rotation.z = q[2]\r\n        t.transform.rotation.w = q[3]\r\n        \r\n        # Send the transform\r\n        self.tf_broadcaster.sendTransform(t)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = RobotStateEstimator()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tf2-and-urdf-debugging",children:"TF2 and URDF Debugging"}),"\n",(0,i.jsx)(n.h3,{id:"tf-tree-visualization-and-analysis",children:"TF Tree Visualization and Analysis"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a node to help analyze and debug the TF tree:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# robot_integration/robot_integration/tf_analyzer.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_msgs.msg import TFMessage\r\nfrom tf2_ros import Buffer, TransformListener\r\nfrom rclpy.qos import QoSProfile\r\nimport time\r\n\r\nclass TFAgent(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_analyzer')\r\n        \r\n        # Create TF buffer and listener\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create timer to periodically analyze TF tree\r\n        self.timer = self.create_timer(5.0, self.analyze_tf_tree)\r\n        \r\n        self.get_logger().info('TF Analyzer started')\r\n\r\n    def analyze_tf_tree(self):\r\n        \"\"\"Analyze the current TF tree structure\"\"\"\r\n        try:\r\n            # Get all available transforms\r\n            transforms = self.tf_buffer.all_frames_as_yaml()\r\n            self.get_logger().info(f'Available TF frames:\\n{transforms}')\r\n            \r\n            # Check specific transforms that should exist\r\n            required_transforms = [\r\n                ('base_link', 'base_footprint'),\r\n                ('base_link', 'lidar_link'),\r\n                ('base_link', 'camera_link'),\r\n                ('base_link', 'imu_link'),\r\n                ('base_link', 'front_left_wheel_link'),\r\n                ('base_link', 'front_right_wheel_link'),\r\n                ('base_link', 'rear_left_wheel_link'),\r\n                ('base_link', 'rear_right_wheel_link'),\r\n            ]\r\n            \r\n            missing_transforms = []\r\n            available_transforms = []\r\n            \r\n            for parent, child in required_transforms:\r\n                try:\r\n                    self.tf_buffer.lookup_transform(parent, child, rclpy.time.Time())\r\n                    available_transforms.append(f'{parent} -> {child}')\r\n                except Exception:\r\n                    missing_transforms.append(f'{parent} -> {child}')\r\n            \r\n            if available_transforms:\r\n                self.get_logger().info(f'Available transforms: {\", \".join(available_transforms)}')\r\n            \r\n            if missing_transforms:\r\n                self.get_logger().warn(f'Missing transforms: {\", \".join(missing_transforms)}')\r\n            else:\r\n                self.get_logger().info('All required transforms are available!')\r\n        \r\n        except Exception as e:\r\n            self.get_logger().error(f'Error analyzing TF tree: {e}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TFAgent()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-exercise-complete-robot-integration",children:"Practical Exercise: Complete Robot Integration"}),"\n",(0,i.jsx)(n.h3,{id:"launch-file-for-complete-system",children:"Launch File for Complete System"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# launch/complete_robot_system.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import Command, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare arguments\r\n    description_file_arg = DeclareLaunchArgument(\r\n        'description_file',\r\n        default_value='integrated_robot.urdf.xacro',\r\n        description='URDF/XACRO description file with the robot'\r\n    )\r\n    \r\n    # Get URDF via xacro\r\n    robot_description_content = Command(\r\n        [\r\n            PathJoinSubstitution([FindPackageShare(\"my_robot_description\"), \"urdf\", \"integrated_robot.urdf.xacro\"])\r\n        ]\r\n    )\r\n    robot_description = {\"robot_description\": robot_description_content}\r\n\r\n    # Robot State Publisher\r\n    robot_state_publisher_node = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        output='both',\r\n        parameters=[robot_description]\r\n    )\r\n\r\n    # Joint State Publisher\r\n    joint_state_publisher_node = Node(\r\n        package='joint_state_publisher',\r\n        executable='joint_state_publisher',\r\n        name='joint_state_publisher',\r\n        parameters=[{\r\n            'use_sim_time': False,\r\n            'source_list': ['joint_states']\r\n        }]\r\n    )\r\n\r\n    # Custom joint state publisher\r\n    custom_joint_publisher_node = Node(\r\n        package='my_robot_integration',\r\n        executable='joint_state_publisher',\r\n        name='custom_joint_publisher',\r\n        parameters=[{\r\n            'use_sim_time': False,\r\n        }]\r\n    )\r\n\r\n    # Sensor transformer\r\n    sensor_transformer_node = Node(\r\n        package='my_robot_integration',\r\n        executable='sensor_transformer',\r\n        name='sensor_transformer',\r\n    )\r\n\r\n    # Robot state estimator\r\n    state_estimator_node = Node(\r\n        package='my_robot_integration',\r\n        executable='robot_state_estimator',\r\n        name='robot_state_estimator',\r\n    )\r\n\r\n    # TF analyzer\r\n    tf_analyzer_node = Node(\r\n        package='my_robot_integration',\r\n        executable='tf_analyzer',\r\n        name='tf_analyzer',\r\n    )\r\n\r\n    return LaunchDescription([\r\n        description_file_arg,\r\n        robot_state_publisher_node,\r\n        joint_state_publisher_node,\r\n        custom_joint_publisher_node,\r\n        sensor_transformer_node,\r\n        state_estimator_node,\r\n        tf_analyzer_node,\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-integration-issues-and-solutions",children:"Common Integration Issues and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"1-frame-id-mismatch",children:"1. Frame ID Mismatch"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Problem: Sensor data has wrong frame_id\r\n# Solution: Always check and validate frame IDs\r\n\r\nclass RobustSensorProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('robust_sensor_processor')\r\n        self.valid_frames = set()\r\n        \r\n    def sensor_callback(self, msg):\r\n        if msg.header.frame_id not in self.valid_frames:\r\n            # Check if the frame exists in TF\r\n            try:\r\n                # This will raise an exception if the frame doesn't exist\r\n                self.tf_buffer.lookup_transform(\r\n                    'base_link', msg.header.frame_id, rclpy.time.Time())\r\n                self.valid_frames.add(msg.header.frame_id)\r\n            except:\r\n                self.get_logger().warn(f'Invalid frame_id: {msg.header.frame_id}')\r\n                return\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-time-synchronization-issues",children:"2. Time Synchronization Issues"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Problem: Transforms at wrong time\r\n# Solution: Use proper time synchronization\r\n\r\nfrom rclpy.duration import Duration\r\n\r\nclass TimeSyncedProcessor(Node):\r\n    def __init__(self):\r\n        super().__init__('time_synced_processor')\r\n        \r\n    def process_sensor_data(self, sensor_msg):\r\n        try:\r\n            # Add a small buffer to account for processing delay\r\n            transform_time = sensor_msg.header.stamp\r\n            transform_time.sec -= 1  # Look back in time if needed\r\n            \r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link', \r\n                sensor_msg.header.frame_id,\r\n                transform_time,\r\n                timeout=Duration(seconds=0.1))\r\n                \r\n            # Process with transform\r\n            return transform\r\n        except Exception as e:\r\n            self.get_logger().error(f'Time sync error: {e}')\r\n            return None\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-tf-tree-discontinuity",children:"3. TF Tree Discontinuity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Problem: Disconnected frames in TF tree\r\n# Solution: Ensure all frames connect to a common base\r\n\r\nclass TFContinuityChecker(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_continuity_checker')\r\n        \r\n    def check_continuity(self, target_frame, base_frame='base_link'):\r\n        \"\"\"Check if there's a transform path between two frames\"\"\"\r\n        try:\r\n            # This will fail if there's no path between frames\r\n            self.tf_buffer.lookup_transform(\r\n                base_frame, target_frame, rclpy.time.Time())\r\n            return True\r\n        except:\r\n            return False\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"efficient-tf-usage",children:"Efficient TF Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class OptimizedTFNode(Node):\r\n    def __init__(self):\r\n        super().__init__('optimized_tf_node')\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Cache frequently accessed transforms\r\n        self.cached_transforms = {}\r\n        self.cache_timeout = 0.1  # 100ms cache\r\n        \r\n    def get_cached_transform(self, target_frame, source_frame):\r\n        cache_key = f\"{target_frame}_{source_frame}\"\r\n        \r\n        # Check if cached and not expired\r\n        if cache_key in self.cached_transforms:\r\n            transform, timestamp = self.cached_transforms[cache_key]\r\n            current_time = self.get_clock().now()\r\n            \r\n            if (current_time - timestamp).nanoseconds < self.cache_timeout * 1e9:\r\n                return transform\r\n        \r\n        # Get fresh transform\r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                target_frame, source_frame, rclpy.time.Time())\r\n            \r\n            # Cache it\r\n            self.cached_transforms[cache_key] = (transform, self.get_clock().now())\r\n            return transform\r\n        except Exception as e:\r\n            self.get_logger().error(f'TF lookup failed: {e}')\r\n            return None\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This submodule explored the integration between TF2 and URDF:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Understanding the relationship"}),": How URDF provides static transforms and TF2 manages dynamic transforms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Creating complete robot models"}),": With proper URDF structure and all necessary components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robot state publisher integration"}),": Broadcasting URDF-defined transforms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint state management"}),": Publishing dynamic joint states for moving parts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor data transformation"}),": Using TF2 with URDF frames to transform sensor data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debugging and optimization"}),": Techniques for maintaining and optimizing TF trees"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The integration of TF2 and URDF is fundamental to ROS robotics, enabling complex spatial reasoning and sensor fusion in multi-frame robotic systems. In the final submodule for Week 4, we'll apply these concepts in practical exercises."})]})}function f(r={}){const{wrapper:n}={...(0,o.R)(),...r.components};return n?(0,i.jsx)(n,{...r,children:(0,i.jsx)(c,{...r})}):c(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>a,x:()=>s});var t=e(6540);const i={},o=t.createContext(i);function a(r){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function s(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:a(r.components),t.createElement(o.Provider,{value:n},r.children)}}}]);
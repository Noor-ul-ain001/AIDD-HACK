"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[3852],{8364:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"module-3/week-2-isaac-ros-basics/2-1-introduction-to-isaac-ros","title":"Week 2: Isaac ROS Basics","description":"Overview","source":"@site/docs/module-3/week-2-isaac-ros-basics/2-1-introduction-to-isaac-ros.md","sourceDirName":"module-3/week-2-isaac-ros-basics","slug":"/module-3/week-2-isaac-ros-basics/2-1-introduction-to-isaac-ros","permalink":"/docs/module-3/week-2-isaac-ros-basics/2-1-introduction-to-isaac-ros","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-3/week-2-isaac-ros-basics/2-1-introduction-to-isaac-ros.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"difficulty":"intermediate"},"sidebar":"tutorialSidebar","previous":{"title":"3.4: Isaac Sim Practical Exercises","permalink":"/docs/module-3/week-1-introduction/3-4-isaac-sim-practical-exercises"},"next":{"title":"Week 3: Advanced Isaac Sim","permalink":"/docs/module-3/week-3-advanced-isaac-sim/3-1-advanced-isaac-sim-techniques"}}');var s=r(4848),i=r(8453);const o={sidebar_position:1,difficulty:"intermediate"},t="Week 2: Isaac ROS Basics",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Isaac ROS",id:"introduction-to-isaac-ros",level:2},{value:"Key Features of Isaac ROS",id:"key-features-of-isaac-ros",level:3},{value:"Isaac ROS Architecture",id:"isaac-ros-architecture",level:3},{value:"Installing Isaac ROS",id:"installing-isaac-ros",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Installation Method 1: Debian Packages",id:"installation-method-1-debian-packages",level:3},{value:"Installation Method 2: Docker",id:"installation-method-2-docker",level:3},{value:"Core Isaac ROS Packages",id:"core-isaac-ros-packages",level:2},{value:"Isaac ROS AprilTag",id:"isaac-ros-apriltag",level:3},{value:"Isaac ROS Visual SLAM",id:"isaac-ros-visual-slam",level:3},{value:"Launching Isaac ROS Nodes",id:"launching-isaac-ros-nodes",level:2},{value:"Example Launch File",id:"example-launch-file",level:3},{value:"Isaac ROS Perception Pipelines",id:"isaac-ros-perception-pipelines",level:2},{value:"Image Preprocessing Pipeline",id:"image-preprocessing-pipeline",level:3},{value:"Integration with ROS 2 Ecosystem",id:"integration-with-ros-2-ecosystem",level:2},{value:"Connecting Isaac ROS to Standard ROS 2 Nodes",id:"connecting-isaac-ros-to-standard-ros-2-nodes",level:3},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"week-2-isaac-ros-basics",children:"Week 2: Isaac ROS Basics"})}),"\n",(0,s.jsx)(a.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(a.p,{children:"This week introduces Isaac ROS, NVIDIA's robotics platform that combines the Robot Operating System (ROS) with NVIDIA's GPU-accelerated libraries for AI and perception."}),"\n",(0,s.jsx)(a.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(a.p,{children:"By the end of this week, you will:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Understand the fundamentals of Isaac ROS"}),"\n",(0,s.jsx)(a.li,{children:"Set up Isaac ROS for your robotic applications"}),"\n",(0,s.jsx)(a.li,{children:"Implement perception pipelines using Isaac ROS"}),"\n",(0,s.jsx)(a.li,{children:"Integrate Isaac ROS with existing ROS 2 systems"}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"introduction-to-isaac-ros",children:"Introduction to Isaac ROS"}),"\n",(0,s.jsx)(a.p,{children:"Isaac ROS is NVIDIA's accelerated perception and navigation stack built for ROS 2. It provides optimized, hardware-accelerated packages that leverage NVIDIA GPUs to accelerate perception, mapping, and navigation tasks."}),"\n",(0,s.jsx)(a.h3,{id:"key-features-of-isaac-ros",children:"Key Features of Isaac ROS"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Hardware Acceleration"}),": GPU-accelerated algorithms for real-time performance"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Perception Pipeline"}),": Optimized computer vision and deep learning nodes"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Integration"}),": Seamless integration with existing ROS 2 ecosystem"]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Docker Support"}),": Easy deployment with containerized packages"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"isaac-ros-architecture",children:"Isaac ROS Architecture"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{children:"Hardware Layer (NVIDIA Jetson/RTX)\r\n        |\r\nGPU Acceleration Layer\r\n        |\r\nIsaac ROS Packages\r\n        |\r\nROS 2 Middleware\r\n        |\r\nApplications\n"})}),"\n",(0,s.jsx)(a.h2,{id:"installing-isaac-ros",children:"Installing Isaac ROS"}),"\n",(0,s.jsx)(a.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,s.jsxs)(a.table,{children:[(0,s.jsx)(a.thead,{children:(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.th,{children:"Component"}),(0,s.jsx)(a.th,{children:"Minimum"}),(0,s.jsx)(a.th,{children:"Recommended"})]})}),(0,s.jsxs)(a.tbody,{children:[(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"GPU"}),(0,s.jsx)(a.td,{children:"NVIDIA GPU with CUDA"}),(0,s.jsx)(a.td,{children:"NVIDIA RTX 3060 or better"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"CUDA"}),(0,s.jsx)(a.td,{children:"11.8+"}),(0,s.jsx)(a.td,{children:"12.0+"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"OS"}),(0,s.jsx)(a.td,{children:"Ubuntu 22.04"}),(0,s.jsx)(a.td,{children:"Ubuntu 22.04 LTS"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"RAM"}),(0,s.jsx)(a.td,{children:"8 GB"}),(0,s.jsx)(a.td,{children:"16+ GB"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:"Storage"}),(0,s.jsx)(a.td,{children:"10 GB"}),(0,s.jsx)(a.td,{children:"20+ GB"})]})]})]}),"\n",(0,s.jsx)(a.h3,{id:"installation-method-1-debian-packages",children:"Installation Method 1: Debian Packages"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-bash",children:'# Add Isaac ROS repository\r\nsudo apt update && sudo apt install software-properties-common\r\nsudo add-apt-repository universe\r\nsudo apt update && sudo apt install curl gnupg lsb-release\r\ncurl -sSL https://repos.packages.nvidia.com/keys/all-keys.gpg | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-archive-keyring.gpg\r\necho "deb [signed-by=/usr/share/keyrings/nvidia-archive-keyring.gpg] https://repos.packages.nvidia.com/isaac/$(lsb_release -cs)/ all main" | sudo tee /etc/apt/sources.list.d/nvidia-isaac-repos-$(lsb_release -cs).list\r\nsudo apt update\r\n\r\n# Install Isaac ROS packages\r\nsudo apt install nvidia-isaac-ros-gem\n'})}),"\n",(0,s.jsx)(a.h3,{id:"installation-method-2-docker",children:"Installation Method 2: Docker"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-bash",children:"# Pull Isaac ROS Docker image\r\ndocker pull nvcr.io/nvidia/isaac-ros:latest\r\n\r\n# Run Isaac ROS container\r\ndocker run --gpus all -it --rm --net=host nvcr.io/nvidia/isaac-ros:latest\n"})}),"\n",(0,s.jsx)(a.h2,{id:"core-isaac-ros-packages",children:"Core Isaac ROS Packages"}),"\n",(0,s.jsx)(a.h3,{id:"isaac-ros-apriltag",children:"Isaac ROS AprilTag"}),"\n",(0,s.jsx)(a.p,{children:"Detect and estimate poses of AprilTag markers:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom isaac_ros_apriltag_interfaces.msg import AprilTagDetectionArray\r\n\r\nclass AprilTagDetector(Node):\r\n    def __init__(self):\r\n        super().__init__('apriltag_detector')\r\n        \r\n        # Subscribe to camera image\r\n        self.image_sub = self.create_subscription(\r\n            Image,\r\n            '/camera/image_raw',\r\n            self.image_callback,\r\n            10\r\n        )\r\n        \r\n        # Publisher for detections\r\n        self.detection_pub = self.create_publisher(\r\n            AprilTagDetectionArray,\r\n            '/apriltag_detections',\r\n            10\r\n        )\r\n    \r\n    def image_callback(self, msg):\r\n        # Process image for AprilTag detection\r\n        # (Actual processing handled by Isaac ROS node)\r\n        pass\n"})}),"\n",(0,s.jsx)(a.h3,{id:"isaac-ros-visual-slam",children:"Isaac ROS Visual SLAM"}),"\n",(0,s.jsx)(a.p,{children:"Real-time visual SLAM for localization and mapping:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, CameraInfo\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav_msgs.msg import Odometry\r\n\r\nclass VisualSLAMNode(Node):\r\n    def __init__(self):\r\n        super().__init__('visual_slam')\r\n        \r\n        # Subscribe to stereo camera or RGB-D data\r\n        self.left_image_sub = self.create_subscription(\r\n            Image,\r\n            '/camera/left/image_raw',\r\n            self.left_image_callback,\r\n            10\r\n        )\r\n        \r\n        self.right_image_sub = self.create_subscription(\r\n            Image,\r\n            '/camera/right/image_raw',\r\n            self.right_image_callback,\r\n            10\r\n        )\r\n        \r\n        # Publishers for pose and map\r\n        self.pose_pub = self.create_publisher(PoseStamped, '/visual_slam/pose', 10)\r\n        self.odom_pub = self.create_publisher(Odometry, '/visual_slam/odometry', 10)\n"})}),"\n",(0,s.jsx)(a.h2,{id:"launching-isaac-ros-nodes",children:"Launching Isaac ROS Nodes"}),"\n",(0,s.jsx)(a.h3,{id:"example-launch-file",children:"Example Launch File"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch_ros.actions import ComposableNodeContainer\r\nfrom launch_ros.descriptions import ComposableNode\r\n\r\ndef generate_launch_description():\r\n    # Isaac ROS AprilTag container\r\n    apriltag_container = ComposableNodeContainer(\r\n        name='apriltag_container',\r\n        namespace='',\r\n        package='rclcpp_components',\r\n        executable='component_container_mt',\r\n        composable_node_descriptions=[\r\n            ComposableNode(\r\n                package='isaac_ros_apriltag',\r\n                plugin='nvidia::isaac_ros::apriltag::AprilTagNode',\r\n                name='apriltag',\r\n                parameters=[{\r\n                    'family': 'tag36h11',\r\n                    'max_tags': 10,\r\n                    'tag_size': 0.166\r\n                }]\r\n            )\r\n        ],\r\n        output='screen',\r\n    )\r\n\r\n    return LaunchDescription([apriltag_container])\n"})}),"\n",(0,s.jsx)(a.h2,{id:"isaac-ros-perception-pipelines",children:"Isaac ROS Perception Pipelines"}),"\n",(0,s.jsx)(a.h3,{id:"image-preprocessing-pipeline",children:"Image Preprocessing Pipeline"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-python",children:"# Isaac ROS provides optimized image preprocessing nodes\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import ComposableNodeContainer\r\nfrom launch_ros.descriptions import ComposableNode\r\n\r\ndef generate_image_preprocessing_pipeline():\r\n    image_processing_container = ComposableNodeContainer(\r\n        name='image_processing_container',\r\n        namespace='',\r\n        package='rclcpp_components',\r\n        executable='component_container_mt',\r\n        composable_node_descriptions=[\r\n            # Image resize node\r\n            ComposableNode(\r\n                package='isaac_ros_image_proc',\r\n                plugin='nvidia::isaac_ros::image_proc::ResizeNode',\r\n                name='resize_node',\r\n                parameters=[{\r\n                    'output_width': 640,\r\n                    'output_height': 480,\r\n                }],\r\n                remappings=[\r\n                    ('image', 'camera/image_raw'),\r\n                    ('camera_info', 'camera/camera_info'),\r\n                    ('resized/image', 'camera/image_resized'),\r\n                    ('resized/camera_info', 'camera/camera_info_resized'),\r\n                ],\r\n            ),\r\n            \r\n            # Image format converter\r\n            ComposableNode(\r\n                package='isaac_ros_image_proc',\r\n                plugin='nvidia::isaac_ros::image_proc::FormatConverterNode',\r\n                name='format_converter_node',\r\n                remappings=[\r\n                    ('image', 'camera/image_resized'),\r\n                    ('camera_info', 'camera/camera_info_resized'),\r\n                    ('output/image', 'camera/image_formatted'),\r\n                    ('output/camera_info', 'camera/camera_info_formatted'),\r\n                ],\r\n            ),\r\n        ],\r\n        output='screen',\r\n    )\r\n    \r\n    return LaunchDescription([image_processing_container])\n"})}),"\n",(0,s.jsx)(a.h2,{id:"integration-with-ros-2-ecosystem",children:"Integration with ROS 2 Ecosystem"}),"\n",(0,s.jsx)(a.h3,{id:"connecting-isaac-ros-to-standard-ros-2-nodes",children:"Connecting Isaac ROS to Standard ROS 2 Nodes"}),"\n",(0,s.jsx)(a.p,{children:"Isaac ROS nodes publish standard ROS 2 message types, making them compatible with the broader ROS ecosystem:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-python",children:"# Standard ROS 2 node consuming Isaac ROS output\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom sensor_msgs.msg import Image\r\n\r\nclass IsaacIntegrationNode(Node):\r\n    def __init__(self):\r\n        super().__init__('isaac_integration_node')\r\n        \r\n        # Subscribe to Isaac ROS pose output\r\n        self.pose_sub = self.create_subscription(\r\n            PoseStamped,\r\n            '/visual_slam/pose',\r\n            self.pose_callback,\r\n            10\r\n        )\r\n        \r\n        # Subscribe to Isaac ROS processed image\r\n        self.processed_image_sub = self.create_subscription(\r\n            Image,\r\n            '/isaac_ros/image_processed',\r\n            self.image_callback,\r\n            10\r\n        )\r\n    \r\n    def pose_callback(self, msg):\r\n        # Use Isaac ROS pose in standard ROS 2 application\r\n        self.get_logger().info(f'Position: x={msg.pose.position.x}, y={msg.pose.position.y}')\r\n    \r\n    def image_callback(self, msg):\r\n        # Process Isaac ROS accelerated image\r\n        self.get_logger().info(f'Received processed image: {msg.width}x{msg.height}')\n"})}),"\n",(0,s.jsx)(a.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,s.jsx)(a.p,{children:"This week's exercise involves setting up an Isaac ROS perception pipeline:"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsx)(a.li,{children:"Install Isaac ROS on your development platform"}),"\n",(0,s.jsx)(a.li,{children:"Configure camera input for Isaac ROS processing"}),"\n",(0,s.jsx)(a.li,{children:"Implement an AprilTag detection pipeline"}),"\n",(0,s.jsx)(a.li,{children:"Integrate the pipeline with a navigation system"}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(a.p,{children:"This week introduced Isaac ROS, NVIDIA's accelerated robotics platform for perception and navigation. You've learned about installation, core packages, and integration with ROS 2. Next week, we'll explore advanced Isaac Sim techniques."})]})}function p(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,a,r)=>{r.d(a,{R:()=>o,x:()=>t});var n=r(6540);const s={},i=n.createContext(s);function o(e){const a=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);
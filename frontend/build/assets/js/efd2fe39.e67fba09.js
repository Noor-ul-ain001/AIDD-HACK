"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[3299],{8310:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-1/week-2-nodes-topics/2-3-topic-design-patterns","title":"2.3: Topic Design Patterns and Best Practices","description":"Overview","source":"@site/docs/module-1/week-2-nodes-topics/2-3-topic-design-patterns.md","sourceDirName":"module-1/week-2-nodes-topics","slug":"/module-1/week-2-nodes-topics/2-3-topic-design-patterns","permalink":"/docs/module-1/week-2-nodes-topics/2-3-topic-design-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-1/week-2-nodes-topics/2-3-topic-design-patterns.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"difficulty":"advanced"},"sidebar":"tutorialSidebar","previous":{"title":"2.2: Working with ROS 2 Topics","permalink":"/docs/module-1/week-2-nodes-topics/2-2-working-with-topics"},"next":{"title":"2.4: Practical Exercises - Advanced Topics and Node Integration","permalink":"/docs/module-1/week-2-nodes-topics/2-4-practical-topics-exercises"}}');var t=n(4848),a=n(8453);const r={sidebar_position:3,difficulty:"advanced"},l="2.3: Topic Design Patterns and Best Practices",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Topic Design Patterns",id:"topic-design-patterns",level:2},{value:"1. Event-Driven Pattern",id:"1-event-driven-pattern",level:3},{value:"2. Data Aggregation Pattern",id:"2-data-aggregation-pattern",level:3},{value:"3. Hierarchical Topic Pattern",id:"3-hierarchical-topic-pattern",level:3},{value:"4. State Synchronization Pattern",id:"4-state-synchronization-pattern",level:3},{value:"Data Serialization and Bandwidth Optimization",id:"data-serialization-and-bandwidth-optimization",level:2},{value:"Efficient Message Design",id:"efficient-message-design",level:3},{value:"Data Compression and Downsampling",id:"data-compression-and-downsampling",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Advanced QoS Configurations",id:"advanced-qos-configurations",level:2},{value:"Real-time Performance QoS",id:"real-time-performance-qos",level:3},{value:"Reliable Communication QoS",id:"reliable-communication-qos",level:3},{value:"Best-effort Communication QoS",id:"best-effort-communication-qos",level:3},{value:"Error Handling and Fault Tolerance",id:"error-handling-and-fault-tolerance",level:2},{value:"Publisher with Error Recovery",id:"publisher-with-error-recovery",level:3},{value:"Subscriber with Validation",id:"subscriber-with-validation",level:3},{value:"Topic Monitoring and Diagnostics",id:"topic-monitoring-and-diagnostics",level:2},{value:"Diagnostic Publisher for Topics",id:"diagnostic-publisher-for-topics",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Management for High-Frequency Topics",id:"memory-management-for-high-frequency-topics",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"23-topic-design-patterns-and-best-practices",children:"2.3: Topic Design Patterns and Best Practices"})}),"\n",(0,t.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(s.p,{children:"This submodule covers advanced topic design patterns and best practices to create efficient, maintainable, and robust ROS 2 applications."}),"\n",(0,t.jsx)(s.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(s.p,{children:"By the end of this submodule, you will:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Apply advanced design patterns for topics"}),"\n",(0,t.jsx)(s.li,{children:"Understand data serialization and bandwidth considerations"}),"\n",(0,t.jsx)(s.li,{children:"Implement proper error handling and fault tolerance"}),"\n",(0,t.jsx)(s.li,{children:"Design scalable topic architectures"}),"\n",(0,t.jsx)(s.li,{children:"Use advanced QoS configurations effectively"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"topic-design-patterns",children:"Topic Design Patterns"}),"\n",(0,t.jsx)(s.h3,{id:"1-event-driven-pattern",children:"1. Event-Driven Pattern"}),"\n",(0,t.jsx)(s.p,{children:"Use topics to notify other nodes of system events:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'# Event publisher\nfrom std_msgs.msg import String\n\nclass EventPublisher(Node):\n    def __init__(self):\n        super().__init__(\'event_publisher\')\n        self.event_pub = self.create_publisher(String, \'system_events\', 10)\n    \n    def publish_event(self, event_type, details=""):\n        msg = String()\n        msg.data = f"{event_type}:{details}"\n        self.event_pub.publish(msg)\n\n# Usage example\nevent_publisher = EventPublisher()\nevent_publisher.publish_event("SENSOR_FAILURE", "Lidar sensor disconnected")\n'})}),"\n",(0,t.jsx)(s.h3,{id:"2-data-aggregation-pattern",children:"2. Data Aggregation Pattern"}),"\n",(0,t.jsx)(s.p,{children:"Combine multiple data sources into a single topic:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from sensor_msgs.msg import LaserScan, Imu\nfrom geometry_msgs.msg import Twist\nfrom my_robot_msgs.msg import RobotStatus  # Custom aggregated message\n\nclass DataAggregator(Node):\n    def __init__(self):\n        super().__init__('data_aggregator')\n        \n        # Subscriptions to multiple data sources\n        self.lidar_sub = self.create_subscription(\n            LaserScan, 'scan', self.lidar_callback, 10)\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10)\n        self.cmd_sub = self.create_subscription(\n            Twist, 'cmd_vel', self.cmd_callback, 10)\n        \n        # Aggregated output\n        self.status_pub = self.create_publisher(RobotStatus, 'robot_status', 10)\n        \n        self.last_lidar = None\n        self.last_imu = None\n        self.last_cmd = None\n    \n    def lidar_callback(self, msg):\n        self.last_lidar = msg\n        self.publish_aggregated_status()\n    \n    def imu_callback(self, msg):\n        self.last_imu = msg\n        self.publish_aggregated_status()\n    \n    def cmd_callback(self, msg):\n        self.last_cmd = msg\n        self.publish_aggregated_status()\n    \n    def publish_aggregated_status(self):\n        if all([self.last_lidar, self.last_imu, self.last_cmd]):\n            msg = RobotStatus()\n            msg.header.stamp = self.get_clock().now().to_msg()\n            msg.lidar_data = self.last_lidar.ranges[:10]  # Simplified\n            msg.imu_data.orientation = self.last_imu.orientation\n            msg.command.linear = self.last_cmd.linear\n            msg.command.angular = self.last_cmd.angular\n            \n            self.status_pub.publish(msg)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"3-hierarchical-topic-pattern",children:"3. Hierarchical Topic Pattern"}),"\n",(0,t.jsx)(s.p,{children:"Organize topics in a hierarchy based on robot components:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"# Good topic naming structure\n# /robot_name/system/component/data_type\n# Examples:\n# /turtle1/sensors/lidar/scan\n# /turtle1/motors/wheel_front_left/velocity\n# /turtle1/control/cmd_vel\n# /arm_1/joint_states/position\n# /arm_1/end_effector/pose\n"})}),"\n",(0,t.jsx)(s.h3,{id:"4-state-synchronization-pattern",children:"4. State Synchronization Pattern"}),"\n",(0,t.jsx)(s.p,{children:"Use a single topic to maintain system state across nodes:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from my_robot_msgs.msg import SystemState\n\nclass StateSynchronizer(Node):\n    def __init__(self):\n        super().__init__('state_synchronizer')\n        \n        # State publisher\n        self.state_pub = self.create_publisher(SystemState, 'system_state', 1)\n        \n        # State subscription (for monitoring)\n        self.state_sub = self.create_subscription(\n            SystemState, 'system_state', self.state_callback, 1)\n        \n        # Initialize system state\n        self.system_state = SystemState()\n    \n    def update_and_publish_state(self, component, value):\n        # Update specific component in system state\n        if component == \"battery\":\n            self.system_state.battery_level = value\n        elif component == \"position\":\n            self.system_state.position = value\n        \n        # Publish entire state (synchronized)\n        self.system_state.header.stamp = self.get_clock().now().to_msg()\n        self.state_pub.publish(self.system_state)\n    \n    def state_callback(self, msg):\n        # Update local state representation\n        self.system_state = msg\n"})}),"\n",(0,t.jsx)(s.h2,{id:"data-serialization-and-bandwidth-optimization",children:"Data Serialization and Bandwidth Optimization"}),"\n",(0,t.jsx)(s.h3,{id:"efficient-message-design",children:"Efficient Message Design"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"# Good: Compact message design\n# CompactSensorData.msg\nfloat32[3] position  # Instead of separate x, y, z\nuint8 sensor_type   # Use enums instead of strings\nfloat32 confidence  # Single confidence value instead of complex structure\n\n# Avoid: Excessive data in messages\n# Don't send entire images on regular topics (use image_transport)\n# Don't send large arrays when only a few values are needed\n"})}),"\n",(0,t.jsx)(s.h3,{id:"data-compression-and-downsampling",children:"Data Compression and Downsampling"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from sensor_msgs.msg import PointCloud2\nimport numpy as np\n\nclass DataCompressor(Node):\n    def __init__(self):\n        super().__init__('data_compressor')\n        \n        self.raw_sub = self.create_subscription(\n            PointCloud2, 'raw_pointcloud', self.raw_callback, 1)\n        self.compressed_pub = self.create_publisher(\n            PointCloud2, 'compressed_pointcloud', 1)\n    \n    def raw_callback(self, msg):\n        # Downsample or filter data before publishing\n        if self.should_compress():\n            compressed_msg = self.downsample_pointcloud(msg)\n            self.compressed_pub.publish(compressed_msg)\n        else:\n            self.compressed_pub.publish(msg)\n    \n    def downsample_pointcloud(self, cloud_msg):\n        # Implementation to reduce point cloud density\n        # This is a simplified example\n        return cloud_msg  # Placeholder\n"})}),"\n",(0,t.jsx)(s.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile\n\nclass RateLimitedPublisher(Node):\n    def __init__(self):\n        super().__init__('rate_limited_publisher')\n        \n        # Create timer for rate limiting\n        self.timer = self.create_timer(0.1, self.publish_callback)  # 10 Hz\n        self.publisher = self.create_publisher(String, 'rate_limited_topic', \n                                             QoSProfile(depth=1))\n        \n        self.counter = 0\n    \n    def publish_callback(self):\n        msg = String()\n        msg.data = f\"Message {self.counter}\"\n        self.publisher.publish(msg)\n        self.counter += 1\n"})}),"\n",(0,t.jsx)(s.h2,{id:"advanced-qos-configurations",children:"Advanced QoS Configurations"}),"\n",(0,t.jsx)(s.h3,{id:"real-time-performance-qos",children:"Real-time Performance QoS"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy\nfrom rclpy.qos import LivelinessPolicy\n\n# For real-time applications\nrealtime_qos = QoSProfile(\n    depth=1,\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=HistoryPolicy.KEEP_LAST,\n    durability=DurabilityPolicy.VOLATILE,\n    liveliness=LivelinessPolicy.AUTOMATIC,\n    deadline=Duration(seconds=1),\n    lifespan=Duration(seconds=30)\n)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"reliable-communication-qos",children:"Reliable Communication QoS"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"# For mission-critical applications\ncritical_qos = QoSProfile(\n    depth=100,  # Larger buffer for important data\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=HistoryPolicy.KEEP_ALL,  # Keep all messages\n    durability=DurabilityPolicy.TRANSIENT_LOCAL  # Persist messages\n)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"best-effort-communication-qos",children:"Best-effort Communication QoS"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"# For high-frequency, non-critical data\nbest_effort_qos = QoSProfile(\n    depth=5,  # Small buffer for frequent updates\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    history=HistoryPolicy.KEEP_LAST,\n    durability=DurabilityPolicy.VOLATILE\n)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"error-handling-and-fault-tolerance",children:"Error Handling and Fault Tolerance"}),"\n",(0,t.jsx)(s.h3,{id:"publisher-with-error-recovery",children:"Publisher with Error Recovery"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile\nfrom std_msgs.msg import Header\n\nclass RobustPublisher(Node):\n    def __init__(self):\n        super().__init__('robust_publisher')\n        \n        # Use appropriate QoS for reliability\n        qos_profile = QoSProfile(depth=10, reliability=ReliabilityPolicy.RELIABLE)\n        self.publisher = self.create_publisher(String, 'robust_topic', qos_profile)\n        \n        self.fallback_mode = False\n        self.recovery_counter = 0\n        \n        # Timer to attempt recovery\n        self.recovery_timer = self.create_timer(5.0, self.recovery_callback)\n    \n    def publish_with_fallback(self, msg_data):\n        try:\n            msg = String()\n            msg.data = msg_data\n            self.publisher.publish(msg)\n        except Exception as e:\n            self.get_logger().error(f'Publish failed: {e}')\n            self.fallback_mode = True\n            self.handle_publish_failure(msg_data)\n    \n    def handle_publish_failure(self, msg_data):\n        # Log error for later analysis\n        self.get_logger().error(f'Failed to publish: {msg_data}')\n        # Implement appropriate fallback behavior\n        # (e.g., store in local buffer, send to alternative topic, etc.)\n    \n    def recovery_callback(self):\n        if self.fallback_mode:\n            self.recovery_counter += 1\n            if self.recovery_counter >= 3:  # Try recovery after 3 attempts\n                self.attempt_recovery()\n    \n    def attempt_recovery(self):\n        self.get_logger().info('Attempting to recover publisher...')\n        try:\n            # Reinitialize publisher if needed\n            qos_profile = QoSProfile(depth=10, reliability=ReliabilityPolicy.RELIABLE)\n            self.publisher = self.create_publisher(String, 'robust_topic', qos_profile)\n            self.fallback_mode = False\n            self.recovery_counter = 0\n            self.get_logger().info('Publisher recovery successful')\n        except Exception as e:\n            self.get_logger().error(f'Publisher recovery failed: {e}')\n"})}),"\n",(0,t.jsx)(s.h3,{id:"subscriber-with-validation",children:"Subscriber with Validation"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from std_msgs.msg import Float32\n\nclass ValidatingSubscriber(Node):\n    def __init__(self):\n        super().__init__('validating_subscriber')\n        \n        self.subscription = self.create_subscription(\n            Float32, 'sensor_value', self.sensor_callback, 10)\n        \n        # Store previous values for change detection\n        self.previous_values = []\n        self.max_change_rate = 10.0  # Max acceptable change per second\n        self.last_time = self.get_clock().now()\n    \n    def sensor_callback(self, msg):\n        current_time = self.get_clock().now()\n        time_diff = (current_time - self.last_time).nanoseconds / 1e9  # seconds\n        \n        # Validate message value\n        if not self.is_value_valid(msg.data):\n            self.get_logger().warn(f'Invalid sensor value received: {msg.data}')\n            return\n        \n        # Check for excessive changes\n        if len(self.previous_values) > 0 and time_diff > 0:\n            rate_of_change = abs(msg.data - self.previous_values[-1]) / time_diff\n            if rate_of_change > self.max_change_rate:\n                self.get_logger().warn(f'Excessive rate of change detected: {rate_of_change}')\n        \n        # Store value and update time\n        self.previous_values.append(msg.data)\n        self.last_time = current_time\n        \n        # Process valid message\n        self.process_sensor_value(msg.data)\n    \n    def is_value_valid(self, value):\n        # Example validation: check for reasonable sensor range\n        return -100.0 <= value <= 100.0\n    \n    def process_sensor_value(self, value):\n        # Process the validated sensor value\n        self.get_logger().info(f'Processing sensor value: {value}')\n"})}),"\n",(0,t.jsx)(s.h2,{id:"topic-monitoring-and-diagnostics",children:"Topic Monitoring and Diagnostics"}),"\n",(0,t.jsx)(s.h3,{id:"diagnostic-publisher-for-topics",children:"Diagnostic Publisher for Topics"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue\n\nclass TopicDiagnostics(Node):\n    def __init__(self):\n        super().__init__('topic_diagnostics')\n        \n        self.diag_pub = self.create_publisher(DiagnosticArray, '/diagnostics', 1)\n        self.status_timer = self.create_timer(1.0, self.publish_diagnostics)\n        \n        # Track topic statistics\n        self.topic_stats = {\n            'topic_name': {\n                'message_count': 0,\n                'last_message_time': None,\n                'avg_frequency': 0.0\n            }\n        }\n    \n    def publish_diagnostics(self):\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = self.get_clock().now().to_msg()\n        \n        for topic_name, stats in self.topic_stats.items():\n            status = DiagnosticStatus()\n            status.name = f'Topic {topic_name}'\n            status.hardware_id = 'ROS2'\n            \n            # Determine status level based on statistics\n            if stats['message_count'] == 0:\n                status.level = DiagnosticStatus.ERROR\n                status.message = 'No messages received'\n            elif stats['avg_frequency'] < 0.1:  # Less than 0.1 Hz\n                status.level = DiagnosticStatus.WARN\n                status.message = f'Low frequency: {stats[\"avg_frequency\"]:.2f} Hz'\n            else:\n                status.level = DiagnosticStatus.OK\n                status.message = f'Active: {stats[\"avg_frequency\"]:.2f} Hz'\n            \n            # Add key-value pairs\n            status.values = [\n                KeyValue(key='Message Count', value=str(stats['message_count'])),\n                KeyValue(key='Frequency', value=f'{stats[\"avg_frequency\"]:.2f} Hz')\n            ]\n            \n            diag_array.status.append(status)\n        \n        self.diag_pub.publish(diag_array)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(s.h3,{id:"memory-management-for-high-frequency-topics",children:"Memory Management for High-Frequency Topics"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from std_msgs.msg import Float32MultiArray\nimport weakref\n\nclass EfficientHighFreqSubscriber(Node):\n    def __init__(self):\n        super().__init__('efficient_subscriber')\n        \n        # Use appropriate QoS for high-frequency data\n        qos = QoSProfile(depth=1, reliability=ReliabilityPolicy.BEST_EFFORT)\n        self.subscription = self.create_subscription(\n            Float32MultiArray, 'high_freq_data', self.data_callback, qos)\n        \n        # Limit stored references to prevent memory leaks\n        self.processed_messages = []\n        self.max_stored_messages = 100\n    \n    def data_callback(self, msg):\n        # Process message immediately\n        processed_data = self.process_message(msg)\n        \n        # Store limited history to prevent memory buildup\n        self.processed_messages.append(processed_data)\n        if len(self.processed_messages) > self.max_stored_messages:\n            self.processed_messages = self.processed_messages[-50:]  # Keep last 50\n        \n        # Don't store references to msg if not needed\n        del msg  # Just a reference, doesn't free the actual message\n"})}),"\n",(0,t.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(s.p,{children:"This submodule covered advanced topic design patterns, bandwidth optimization, robust error handling, and performance considerations for ROS 2 topics. In the final submodule for Week 2, we'll put these concepts into practice with more complex examples."})]})}function p(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>l});var i=n(6540);const t={},a=i.createContext(t);function r(e){const s=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:s},e.children)}}}]);
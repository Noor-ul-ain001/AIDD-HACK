"use strict";(globalThis.webpackChunkphysical_ai_platform_frontend=globalThis.webpackChunkphysical_ai_platform_frontend||[]).push([[1854],{2709:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>f});const s=JSON.parse('{"id":"module-1/week-4-tf-urdf/4-1-understanding-tf2","title":"4.1: Understanding ROS 2 TF2 (Transform Library)","description":"Overview","source":"@site/docs/module-1/week-4-tf-urdf/4-1-understanding-tf2.md","sourceDirName":"module-1/week-4-tf-urdf","slug":"/module-1/week-4-tf-urdf/4-1-understanding-tf2","permalink":"/docs/module-1/week-4-tf-urdf/4-1-understanding-tf2","draft":false,"unlisted":false,"editUrl":"https://github.com/noor-ana/physical-ai-platform/tree/main/docs/module-1/week-4-tf-urdf/4-1-understanding-tf2.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"difficulty":"beginner"},"sidebar":"tutorialSidebar","previous":{"title":"3.4: Practical Exercises - Communication Patterns Integration","permalink":"/docs/module-1/week-3-services-actions/3-4-communication-practical-exercises"},"next":{"title":"4.2: Understanding URDF (Unified Robot Description Format)","permalink":"/docs/module-1/week-4-tf-urdf/4-2-understanding-urdf"}}');var t=e(4848),o=e(8453);const a={sidebar_position:1,difficulty:"beginner"},i="4.1: Understanding ROS 2 TF2 (Transform Library)",l={},f=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Spatial Relationships in Robotics",id:"spatial-relationships-in-robotics",level:2},{value:"Coordinate Frames",id:"coordinate-frames",level:3},{value:"Why TF2 is Needed",id:"why-tf2-is-needed",level:3},{value:"TF2 Architecture",id:"tf2-architecture",level:2},{value:"Key Components",id:"key-components",level:3},{value:"TF2 vs TF",id:"tf2-vs-tf",level:3},{value:"Broadcasting Transforms",id:"broadcasting-transforms",level:2},{value:"Static Transforms",id:"static-transforms",level:3},{value:"Dynamic Transforms",id:"dynamic-transforms",level:3},{value:"Listening to Transforms",id:"listening-to-transforms",level:2},{value:"Basic Transform Listener",id:"basic-transform-listener",level:3},{value:"Transform with Time Lookup",id:"transform-with-time-lookup",level:3},{value:"Transforming Data",id:"transforming-data",level:2},{value:"Transforming Points, Vectors, and Poses",id:"transforming-points-vectors-and-poses",level:3},{value:"TF2 in C++",id:"tf2-in-c",level:2},{value:"Static Transform Broadcaster (C++)",id:"static-transform-broadcaster-c",level:3},{value:"Transform Listener (C++)",id:"transform-listener-c",level:3},{value:"TF2 Best Practices",id:"tf2-best-practices",level:2},{value:"Frame Naming Conventions",id:"frame-naming-conventions",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Transform Error Handling",id:"transform-error-handling",level:3},{value:"TF2 Tools and Debugging",id:"tf2-tools-and-debugging",level:2},{value:"Command-Line Tools",id:"command-line-tools",level:3},{value:"TF2 Monitor",id:"tf2-monitor",level:3},{value:"Common TF2 Issues and Solutions",id:"common-tf2-issues-and-solutions",level:2},{value:"1. Transform Not Available Error",id:"1-transform-not-available-error",level:3},{value:"2. Timing Issues",id:"2-timing-issues",level:3},{value:"Summary",id:"summary",level:2}];function m(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"41-understanding-ros-2-tf2-transform-library",children:"4.1: Understanding ROS 2 TF2 (Transform Library)"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"This submodule introduces TF2 (Transform Library), ROS 2's system for tracking coordinate frame relationships over time. TF2 is essential for robotics applications that need to transform data between different coordinate frames, such as sensor data, robot poses, and map coordinates."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this submodule, you will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the concept of coordinate frames and transformations"}),"\n",(0,t.jsx)(n.li,{children:"Learn how TF2 works in ROS 2"}),"\n",(0,t.jsx)(n.li,{children:"Create and broadcast transforms using TF2"}),"\n",(0,t.jsx)(n.li,{children:"Listen to and use transforms from TF2"}),"\n",(0,t.jsx)(n.li,{children:"Apply TF2 in practical robotic scenarios"}),"\n",(0,t.jsx)(n.li,{children:"Debug common TF2 issues"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"spatial-relationships-in-robotics",children:"Spatial Relationships in Robotics"}),"\n",(0,t.jsx)(n.h3,{id:"coordinate-frames",children:"Coordinate Frames"}),"\n",(0,t.jsx)(n.p,{children:"In robotics, we use coordinate frames to provide context for spatial measurements. Common frames include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Base frame"})," (",(0,t.jsx)(n.code,{children:"base_link"}),", ",(0,t.jsx)(n.code,{children:"base_footprint"}),"): Robot's center"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor frames"})," (",(0,t.jsx)(n.code,{children:"camera_frame"}),", ",(0,t.jsx)(n.code,{children:"laser_frame"}),"): Sensor mounting positions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"World/mapping frame"})," (",(0,t.jsx)(n.code,{children:"map"}),", ",(0,t.jsx)(n.code,{children:"odom"}),"): Reference for position tracking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"End-effector frame"})," (",(0,t.jsx)(n.code,{children:"gripper"}),", ",(0,t.jsx)(n.code,{children:"tool0"}),"): Robot's working point"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"why-tf2-is-needed",children:"Why TF2 is Needed"}),"\n",(0,t.jsx)(n.p,{children:"When a robot has multiple sensors and moving parts, we need a way to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Relate data from different sensors"}),"\n",(0,t.jsx)(n.li,{children:"Track the position of robot parts over time"}),"\n",(0,t.jsx)(n.li,{children:"Transform points between coordinate systems"}),"\n",(0,t.jsx)(n.li,{children:"Maintain a consistent spatial understanding"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"tf2-architecture",children:"TF2 Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transform Buffer"}),": Stores all frame relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transform Listener"}),": Subscribes to transform data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transform Broadcaster"}),": Publishes new transform data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TF2 Message Types"}),": ",(0,t.jsx)(n.code,{children:"tf2_msgs/TFMessage"})," and related types"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"tf2-vs-tf",children:"TF2 vs TF"}),"\n",(0,t.jsx)(n.p,{children:"TF2 is the second generation of the transform library with improvements:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Better performance"}),"\n",(0,t.jsx)(n.li,{children:"More intuitive API"}),"\n",(0,t.jsx)(n.li,{children:"Support for custom datatypes"}),"\n",(0,t.jsx)(n.li,{children:"Cleaner separation of concerns"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"broadcasting-transforms",children:"Broadcasting Transforms"}),"\n",(0,t.jsx)(n.h3,{id:"static-transforms",children:"Static Transforms"}),"\n",(0,t.jsx)(n.p,{children:"Static transforms are constant relationships between frames (e.g., sensor mounted on robot)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Python Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import StaticTransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\nimport tf_transformations\r\n\r\nclass StaticFramePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('static_frame_publisher')\r\n        \r\n        # Create a StaticTransformBroadcaster\r\n        self.tf_static_broadcaster = StaticTransformBroadcaster(self)\r\n        \r\n        # Publish the static transform\r\n        self.publish_static_transform()\r\n    \r\n    def publish_static_transform(self):\r\n        # Create a transform\r\n        t = TransformStamped()\r\n        \r\n        # Set header\r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = 'base_link'\r\n        t.child_frame_id = 'laser_frame'\r\n        \r\n        # Set translation (x, y, z)\r\n        t.transform.translation.x = 0.1  # 10 cm forward\r\n        t.transform.translation.y = 0.0  # No lateral offset\r\n        t.transform.translation.z = 0.2  # 20 cm up\r\n        \r\n        # Set rotation (as quaternion)\r\n        # For a simple 90-degree rotation around Z axis\r\n        q = tf_transformations.quaternion_from_euler(0, 0, 1.5708)  # 90 degrees in radians\r\n        t.transform.rotation.x = q[0]\r\n        t.transform.rotation.y = q[1]\r\n        t.transform.rotation.z = q[2]\r\n        t.transform.rotation.w = q[3]\r\n        \r\n        # Send the transform\r\n        self.tf_static_broadcaster.sendTransform(t)\r\n        self.get_logger().info('Published static transform: base_link -> laser_frame')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = StaticFramePublisher()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-transforms",children:"Dynamic Transforms"}),"\n",(0,t.jsx)(n.p,{children:"Dynamic transforms change over time (e.g., rotating sensor, moving robot parts)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Python Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\nimport tf_transformations\r\nimport math\r\n\r\nclass DynamicFramePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('dynamic_frame_publisher')\r\n        \r\n        # Create a TransformBroadcaster\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n        \r\n        # Create a timer to periodically broadcast transforms\r\n        self.timer = self.create_timer(0.1, self.broadcast_transform)  # 10 Hz\r\n        self.time_step = 0.0\r\n    \r\n    def broadcast_transform(self):\r\n        # Create a transform\r\n        t = TransformStamped()\r\n        \r\n        # Set header\r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = 'base_link'\r\n        t.child_frame_id = 'rotating_sensor'\r\n        \r\n        # Make the transform oscillate for demonstration\r\n        # Translation moves in a circle\r\n        radius = 0.3  # 30 cm radius\r\n        t.transform.translation.x = radius * math.cos(self.time_step)\r\n        t.transform.translation.y = radius * math.sin(self.time_step)\r\n        t.transform.translation.z = 0.5  # Fixed height\r\n        \r\n        # Rotation changes over time\r\n        q = tf_transformations.quaternion_from_euler(0, 0, self.time_step)\r\n        t.transform.rotation.x = q[0]\r\n        t.transform.rotation.y = q[1]\r\n        t.transform.rotation.z = q[2]\r\n        t.transform.rotation.w = q[3]\r\n        \r\n        # Send the transform\r\n        self.tf_broadcaster.sendTransform(t)\r\n        \r\n        self.time_step += 0.1  # Increment for next iteration\r\n        \r\n        if self.time_step % 10 < 0.1:  # Log every 10 seconds\r\n            self.get_logger().info(f'Published dynamic transform: base_link -> rotating_sensor')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = DynamicFramePublisher()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"listening-to-transforms",children:"Listening to Transforms"}),"\n",(0,t.jsx)(n.h3,{id:"basic-transform-listener",children:"Basic Transform Listener"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Python Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom geometry_msgs.msg import PointStamped\r\n\r\nclass FrameListener(Node):\r\n    def __init__(self):\r\n        super().__init__('frame_listener')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        \r\n        # Create a transform listener\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create a timer to periodically look up transforms\r\n        self.timer = self.create_timer(1.0, self.lookup_transform)\r\n    \r\n    def lookup_transform(self):\r\n        try:\r\n            # Look up the transform from 'base_link' to 'laser_frame'\r\n            now = rclpy.time.Time()\r\n            trans = self.tf_buffer.lookup_transform(\r\n                'base_link',  # Target frame\r\n                'laser_frame',  # Source frame\r\n                now)  # Time (use 'now' for most recent)\r\n            \r\n            # Log the transform\r\n            self.get_logger().info(\r\n                f'Translation: x={trans.transform.translation.x:.3f}, '\r\n                f'y={trans.transform.translation.y:.3f}, '\r\n                f'z={trans.transform.translation.z:.3f}')\r\n            self.get_logger().info(\r\n                f'Rotation: x={trans.transform.rotation.x:.3f}, '\r\n                f'y={trans.transform.rotation.y:.3f}, '\r\n                f'z={trans.transform.rotation.z:.3f}, '\r\n                f'w={trans.transform.rotation.w:.3f}')\r\n        \r\n        except Exception as e:\r\n            self.get_logger().error(f'Could not get transform: {str(e)}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = FrameListener()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"transform-with-time-lookup",children:"Transform with Time Lookup"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Python Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom geometry_msgs.msg import PointStamped, TransformStamped\r\nfrom builtin_interfaces.msg import Time\r\nimport time\r\n\r\nclass TimedFrameListener(Node):\r\n    def __init__(self):\r\n        super().__init__('timed_frame_listener')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        \r\n        # Create a transform listener\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Create a publisher for transformed points\r\n        self.point_pub = self.create_publisher(PointStamped, 'transformed_point', 10)\r\n        \r\n        # Timer to demonstrate timed transforms\r\n        self.timer = self.create_timer(2.0, self.lookup_timed_transform)\r\n    \r\n    def lookup_timed_transform(self):\r\n        try:\r\n            # Create a point in the laser frame\r\n            point_in_laser = PointStamped()\r\n            point_in_laser.header.frame_id = 'laser_frame'\r\n            point_in_laser.header.stamp = self.get_clock().now().to_msg()\r\n            point_in_laser.point.x = 1.0  # 1 meter in front of laser\r\n            point_in_laser.point.y = 0.0\r\n            point_in_laser.point.z = 0.0\r\n            \r\n            # Transform the point to base_link frame\r\n            point_in_base = self.tf_buffer.transform(\r\n                point_in_laser,    # Input point\r\n                'base_link',       # Target frame\r\n                timeout=rclpy.duration.Duration(seconds=1.0))  # Timeout\r\n            \r\n            # Log the result\r\n            self.get_logger().info(\r\n                f'Transformed point: ({point_in_base.point.x:.3f}, '\r\n                f'{point_in_base.point.y:.3f}, {point_in_base.point.z:.3f}) '\r\n                f'in base_link frame')\r\n            \r\n            # Publish the transformed point\r\n            self.point_pub.publish(point_in_base)\r\n        \r\n        except Exception as e:\r\n            self.get_logger().error(f'Transform failed: {str(e)}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TimedFrameListener()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"transforming-data",children:"Transforming Data"}),"\n",(0,t.jsx)(n.h3,{id:"transforming-points-vectors-and-poses",children:"Transforming Points, Vectors, and Poses"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Python Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom geometry_msgs.msg import PointStamped, Vector3Stamped, PoseStamped\r\nfrom sensor_msgs.msg import LaserScan\r\n\r\nclass DataTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('data_transformer')\r\n        \r\n        # Create a transform buffer\r\n        self.tf_buffer = Buffer()\r\n        \r\n        # Create a transform listener\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Subscribe to laser scan\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, 'scan', self.scan_callback, 10)\r\n        \r\n        # Publisher for transformed data\r\n        self.transformed_scan_pub = self.create_publisher(\r\n            LaserScan, 'scan_in_base_link', 10)\r\n    \r\n    def scan_callback(self, msg):\r\n        try:\r\n            # Transform the entire scan to base_link frame\r\n            # This is a simplified example - in practice, you'd transform individual points\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link',      # Target frame\r\n                msg.header.frame_id,  # Source frame (usually laser_frame)\r\n                msg.header.stamp,     # Time of the scan\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n            \r\n            # Log that we have the transform\r\n            self.get_logger().info(\r\n                f'Got transform from {msg.header.frame_id} to base_link')\r\n        \r\n        except Exception as e:\r\n            self.get_logger().error(f'Could not transform scan: {str(e)}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = DataTransformer()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"tf2-in-c",children:"TF2 in C++"}),"\n",(0,t.jsx)(n.h3,{id:"static-transform-broadcaster-c",children:"Static Transform Broadcaster (C++)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\r\n#include <tf2_ros/static_transform_broadcaster.h>\r\n#include <geometry_msgs/msg/transform_stamped.hpp>\r\n#include <tf2/LinearMath/Quaternion.h>\r\n\r\nclass StaticFramePublisher : public rclcpp::Node\r\n{\r\npublic:\r\n    StaticFramePublisher() : Node("static_frame_publisher")\r\n    {\r\n        tf_publisher_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(this);\r\n        \r\n        // Publish the static transform\r\n        publish_static_transform();\r\n    }\r\n\r\nprivate:\r\n    void publish_static_transform()\r\n    {\r\n        geometry_msgs::msg::TransformStamped t;\r\n        \r\n        t.header.stamp = this->get_clock()->now();\r\n        t.header.frame_id = "base_link";\r\n        t.child_frame_id = "laser_frame";\r\n        \r\n        // Set translation\r\n        t.transform.translation.x = 0.1;\r\n        t.transform.translation.y = 0.0;\r\n        t.transform.translation.z = 0.2;\r\n        \r\n        // Set rotation (90 degrees around Z axis)\r\n        tf2::Quaternion q;\r\n        q.setRPY(0, 0, 1.5708);  // roll, pitch, yaw\r\n        \r\n        t.transform.rotation.x = q.x();\r\n        t.transform.rotation.y = q.y();\r\n        t.transform.rotation.z = q.z();\r\n        t.transform.rotation.w = q.w();\r\n        \r\n        tf_publisher_->sendTransform(t);\r\n        RCLCPP_INFO(this->get_logger(), "Published static transform: base_link -> laser_frame");\r\n    }\r\n    \r\n    std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_publisher_;\r\n};\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n    rclcpp::init(argc, argv);\r\n    rclcpp::spin(std::make_shared<StaticFramePublisher>());\r\n    rclcpp::shutdown();\r\n    return 0;\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"transform-listener-c",children:"Transform Listener (C++)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\r\n#include <tf2_ros/transform_listener.h>\r\n#include <tf2_ros/buffer.h>\r\n#include <geometry_msgs/msg/transform_stamped.hpp>\r\n\r\nclass FrameListener : public rclcpp::Node\r\n{\r\npublic:\r\n    FrameListener() : Node("frame_listener")\r\n    {\r\n        tf_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());\r\n        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);\r\n        \r\n        // Create a timer to periodically look up transforms\r\n        timer_ = this->create_wall_timer(\r\n            std::chrono::seconds(1),\r\n            std::bind(&FrameListener::lookup_transform, this));\r\n    }\r\n\r\nprivate:\r\n    void lookup_transform()\r\n    {\r\n        try {\r\n            geometry_msgs::msg::TransformStamped transform = tf_buffer_->lookupTransform(\r\n                "base_link",    // Target frame\r\n                "laser_frame",  // Source frame\r\n                tf2::TimePointZero);  // Most recent available\r\n            \r\n            RCLCPP_INFO(this->get_logger(),\r\n                "Translation: x=%f, y=%f, z=%f",\r\n                transform.transform.translation.x,\r\n                transform.transform.translation.y,\r\n                transform.transform.translation.z);\r\n        }\r\n        catch (const tf2::TransformException & ex) {\r\n            RCLCPP_WARN(this->get_logger(), "Could not get transform: %s", ex.what());\r\n        }\r\n    }\r\n\r\n    std::shared_ptr<tf2_ros::Buffer> tf_buffer_;\r\n    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;\r\n    rclcl::TimerBase::SharedPtr timer_;\r\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"tf2-best-practices",children:"TF2 Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"frame-naming-conventions",children:"Frame Naming Conventions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use consistent naming: ",(0,t.jsx)(n.code,{children:"sensor_name_frame"})," (e.g., ",(0,t.jsx)(n.code,{children:"camera_frame"}),", ",(0,t.jsx)(n.code,{children:"lidar_frame"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Use semantic names: ",(0,t.jsx)(n.code,{children:"map"}),", ",(0,t.jsx)(n.code,{children:"odom"}),", ",(0,t.jsx)(n.code,{children:"base_link"}),", ",(0,t.jsx)(n.code,{children:"base_footprint"})]}),"\n",(0,t.jsx)(n.li,{children:"Follow REP-105 conventions for standard frame names"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Efficient transform lookup\r\nclass EfficientTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('efficient_transformer')\r\n        \r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n        \r\n        # Cache transforms for frequently accessed frames\r\n        self.cached_transforms = {}\r\n    \r\n    def get_cached_transform(self, target_frame, source_frame):\r\n        cache_key = f\"{target_frame}_{source_frame}\"\r\n        \r\n        # Try to get from cache first\r\n        if cache_key in self.cached_transforms:\r\n            return self.cached_transforms[cache_key]\r\n        \r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                target_frame, source_frame, rclpy.time.Time())\r\n            # Cache the transform (with appropriate invalidation strategy)\r\n            self.cached_transforms[cache_key] = transform\r\n            return transform\r\n        except Exception as e:\r\n            self.get_logger().error(f'Transform lookup failed: {e}')\r\n            return None\n"})}),"\n",(0,t.jsx)(n.h3,{id:"transform-error-handling",children:"Transform Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from tf2_ros import LookupException, ConnectivityException, ExtrapolationException\r\n\r\nclass RobustTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('robust_transformer')\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n    \r\n    def safe_lookup_transform(self, target_frame, source_frame, time=None):\r\n        try:\r\n            if time is None:\r\n                time = rclpy.time.Time()\r\n            \r\n            transform = self.tf_buffer.lookup_transform(\r\n                target_frame, source_frame, time)\r\n            return transform, True  # Success\r\n        except LookupException:\r\n            self.get_logger().warn(f'Frame {source_frame} does not exist')\r\n            return None, False\r\n        except ConnectivityException:\r\n            self.get_logger().warn(f'No connection from {source_frame} to {target_frame}')\r\n            return None, False\r\n        except ExtrapolationException:\r\n            self.get_logger().warn(f'Transform would require extrapolation')\r\n            return None, False\r\n        except Exception as e:\r\n            self.get_logger().error(f'Unexpected error in transform lookup: {e}')\r\n            return None, False\n"})}),"\n",(0,t.jsx)(n.h2,{id:"tf2-tools-and-debugging",children:"TF2 Tools and Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"command-line-tools",children:"Command-Line Tools"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# View the TF tree\r\nros2 run tf2_tools view_frames\r\n\r\n# Echo a specific transform\r\nros2 run tf2_ros tf2_echo base_link laser_frame\r\n\r\n# View TF tree as image (creates frames.pdf)\r\n# After running view_frames\r\nevince frames.pdf  # or your system's PDF viewer\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tf2-monitor",children:"TF2 Monitor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Monitor TF quality\r\nros2 run tf2_ros tf2_monitor\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-tf2-issues-and-solutions",children:"Common TF2 Issues and Solutions"}),"\n",(0,t.jsx)(n.h3,{id:"1-transform-not-available-error",children:"1. Transform Not Available Error"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Problem: Getting \"could not find transform\" errors\r\n# Solution: Wait for transforms to be available\r\n\r\nimport time\r\nfrom rclpy.duration import Duration\r\n\r\nclass WaitForTransform(Node):\r\n    def __init__(self):\r\n        super().__init__('wait_for_transform')\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n    \r\n    def lookup_with_wait(self):\r\n        try:\r\n            # Wait for transform to become available\r\n            self.tf_buffer.wait_for_transform(\r\n                'base_link', 'laser_frame', \r\n                rclpy.time.Time(),\r\n                timeout=Duration(seconds=1.0))\r\n            \r\n            # Now do the lookup\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link', 'laser_frame', rclpy.time.Time())\r\n            \r\n            return transform\r\n        except Exception as e:\r\n            self.get_logger().error(f'Failed to get transform even after waiting: {e}')\r\n            return None\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-timing-issues",children:"2. Timing Issues"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Problem: Transform at wrong time\r\n# Solution: Use appropriate time synchronization\r\n\r\nclass TimeSyncedTransformer(Node):\r\n    def __init__(self):\r\n        super().__init__('time_synced_transformer')\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n    \r\n    def transform_with_sensor_time(self, sensor_msg):\r\n        try:\r\n            # Use the time from the sensor message for transform\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link', \r\n                sensor_msg.header.frame_id,\r\n                sensor_msg.header.stamp,\r\n                timeout=Duration(seconds=0.1))\r\n            \r\n            return transform\r\n        except Exception as e:\r\n            self.get_logger().error(f'Time-synced transform failed: {e}')\r\n            return None\n"})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This submodule covered the fundamentals of ROS 2 TF2 (Transform Library):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Coordinate frames and transformations in robotics"}),"\n",(0,t.jsx)(n.li,{children:"Broadcasting static and dynamic transforms"}),"\n",(0,t.jsx)(n.li,{children:"Listening to and using transforms"}),"\n",(0,t.jsx)(n.li,{children:"Transforming data between coordinate frames"}),"\n",(0,t.jsx)(n.li,{children:"Best practices and common debugging techniques"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"TF2 is essential for any robotics application that needs to understand spatial relationships between different parts of the robot and its environment. In the next submodule, we'll explore URDF (Unified Robot Description Format), which works closely with TF2 to describe robot structure."})]})}function d(r={}){const{wrapper:n}={...(0,o.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(m,{...r})}):m(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>a,x:()=>i});var s=e(6540);const t={},o=s.createContext(t);function a(r){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function i(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:a(r.components),s.createElement(o.Provider,{value:n},r.children)}}}]);
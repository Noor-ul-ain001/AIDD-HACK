---

sidebar_position: 2

---



# 3.2: Understanding ROS 2 Actions

## Overview

This submodule explores ROS 2 actions, which provide a goal-oriented communication pattern ideal for long-running tasks that may be preempted or require feedback during execution. Actions combine features of both services and topics.

## Learning Objectives

By the end of this submodule, you will:
- Understand the action communication pattern in ROS 2
- Create and implement action servers and clients in Python and C++
- Work with built-in and custom action types
- Implement goal handling with feedback and results
- Compare action usage with topics and services
- Apply appropriate use cases for actions

## Action Communication Pattern

ROS 2 actions implement a **goal-oriented** communication pattern with the following components:

- **Goal**: Request to perform a long-running task
- **Feedback**: Periodic updates during task execution
- **Result**: Final outcome when task completes (success or failure)
- **Preemption**: Ability to cancel or replace an ongoing goal

### When to Use Actions vs Services vs Topics

| Use Actions When | Use Services When | Use Topics When |
|------------------|-------------------|-----------------|
| Long-running tasks | Immediate response needed | Continuous data |
| Need feedback during execution | Simple request/reply | Asynchronous broadcast |
| Tasks can be preempted | Configuration calls | Sensor streams |
| Goal-oriented work | Validation checks | State publishing |
| Cancelable operations | One-time processing | Status updates |

## Action Structure

Each action type has three message definitions:
1. **Goal**: Contains parameters for the action
2. **Result**: Contains the final outcome
3. **Feedback**: Contains intermediate updates during execution

Example: `Fibonacci.action`
```
# Goal definition
int32 order
---
# Result definition
int32[] sequence
---
# Feedback definition
int32[] sequence
```

## Creating Action Servers in Python

### Basic Action Server

```python
import time
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        """Accept or reject a client request to begin an action."""
        self.get_logger().info('Received goal request')
        # Accept all goals for this example
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Accept or reject a client request to cancel an action."""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute the goal and provide feedback."""
        self.get_logger().info('Executing goal...')
        
        # Create feedback message
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]
        
        # Simulate long-running task
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            # Update feedback
            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])
            
            # Publish feedback
            goal_handle.publish_feedback(feedback_msg)
            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')
            
            # Sleep to simulate work
            time.sleep(1)

        # Check if we were canceled
        if goal_handle.is_cancel_requested:
            goal_handle.canceled()
            self.get_logger().info('Goal canceled')
            return Fibonacci.Result()

        # Success
        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Result: {result.sequence}')
        
        return result

def main(args=None):
    rclpy.init(args=args)
    action_server = FibonacciActionServer()
    rclpy.spin(action_server)
    action_server.destroy_node()
    rclpy.shutdown()
```

## Creating Action Clients in Python

### Basic Action Client

```python
import time
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(
            self,
            Fibonacci,
            'fibonacci')

    def send_goal(self, order):
        # Wait for action server
        self._action_client.wait_for_server()
        
        # Create goal message
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order
        
        # Send goal and get future
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)
        
        # Add callback for when goal is accepted
        self._send_goal_future.add_done_callback(self.goal_response_callback)
        
        return self._send_goal_future

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')
        
        # Get result future
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        self.get_logger().info(
            f'Received feedback: {feedback_msg.feedback.sequence}')

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')

def main(args=None):
    rclpy.init(args=args)
    action_client = FibonacciActionClient()
    
    # Send goal
    future = action_client.send_goal(10)
    
    # Spin until goal is complete
    rclpy.spin_until_future_complete(action_client, future)
    
    action_client.destroy_node()
    rclpy.shutdown()
```

## Creating Actions in C++

### Action Server in C++

```cpp
#include <memory>
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>
#include <example_interfaces/action/fibonacci.hpp>

class FibonacciActionServer : public rclcpp::Node
{
public:
    using Fibonacci = example_interfaces::action::Fibonacci;
    using GoalHandleFibonacci = rclcpp_action::ServerGoalHandle<Fibonacci>;

    FibonacciActionServer() : Node("fibonacci_action_server")
    {
        using namespace std::placeholders;

        this->action_server_ = rclcpp_action::create_server<Fibonacci>(
            this->get_node_base_interface(),
            this->get_node_clock_interface(),
            this->get_node_logging_interface(),
            this->get_node_waitables_interface(),
            "fibonacci",
            std::bind(&FibonacciActionServer::handle_goal, this, _1, _2),
            std::bind(&FibonacciActionServer::handle_cancel, this, _1),
            std::bind(&FibonacciActionServer::handle_accepted, this, _1));
    }

private:
    rclcpp_action::Server<Fibonacci>::SharedPtr action_server_;

    rclcpp_action::GoalResponse handle_goal(
        const rclcpp_action::GoalUUID & uuid,
        std::shared_ptr<const Fibonacci::Goal> goal)
    {
        RCLCPP_INFO(this->get_logger(), "Received goal request with order %d", goal->order);
        (void)uuid;
        return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
    }

    rclcpp_action::CancelResponse handle_cancel(
        const std::shared_ptr<GoalHandleFibonacci> goal_handle)
    {
        RCLCPP_INFO(this->get_logger(), "Received cancel request");
        (void)goal_handle;
        return rclcpp_action::CancelResponse::ACCEPT;
    }

    void handle_accepted(const std::shared_ptr<GoalHandleFibonacci> goal_handle)
    {
        using namespace std::placeholders;
        // This needs to return quickly to avoid blocking the executor
        std::thread{std::bind(&FibonacciActionServer::execute, this, _1), goal_handle}.detach();
    }

    void execute(const std::shared_ptr<GoalHandleFibonacci> goal_handle)
    {
        RCLCPP_INFO(this->get_logger(), "Executing goal");

        // Create messages
        auto feedback = std::make_shared<Fibonacci::Feedback>();
        auto result = std::make_shared<Fibonacci::Result>();

        // Initialize sequence
        feedback->sequence = {0, 1};
        
        auto goal = goal_handle->get_goal();
        
        for (int i = 1; i < goal->order; ++i) {
            // Check if there is a cancel request
            if (goal_handle->is_canceling()) {
                result->sequence = feedback->sequence;
                goal_handle->canceled(result);
                RCLCPP_INFO(this->get_logger(), "Goal canceled");
                return;
            }

            // Update sequence
            feedback->sequence.push_back(
                feedback->sequence[i] + feedback->sequence[i - 1]);
            
            // Publish feedback
            goal_handle->publish_feedback(feedback);
            RCLCPP_INFO(this->get_logger(), "Publishing feedback: %s",
                       std::to_string(feedback->sequence.back()).c_str());

            // Sleep to simulate work
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }

        // Check if goal is done
        if (rclcpp::ok()) {
            result->sequence = feedback->sequence;
            goal_handle->succeed(result);
            RCLCPP_INFO(this->get_logger(), "Goal succeeded");
        }
    }
};
```

### Action Client in C++

```cpp
#include <functional>
#include <future>
#include <memory>
#include <string>
#include <thread>

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "example_interfaces/action/fibonacci.hpp"

class FibonacciActionClient : public rclcpp::Node
{
public:
    using Fibonacci = example_interfaces::action::Fibonacci;
    using GoalHandleFibonacci = rclcpp_action::ClientGoalHandle<Fibonacci>;

    explicit FibonacciActionClient(const std::string & action_name)
    : Node("fibonacci_action_client")
    {
        this->client_ptr_ = rclcpp_action::create_client<Fibonacci>(
            this->get_node_base_interface(),
            this->get_node_graph_interface(),
            this->get_node_logging_interface(),
            this->get_node_waitables_interface(),
            action_name);
    }

    void send_goal() {
        using namespace std::placeholders;

        this->timer_ = this->create_wall_timer(
            std::chrono::milliseconds(500),
            std::bind(&FibonacciActionClient::send_goal, this));
        
        if (!this->client_ptr_->wait_for_action_server(std::chrono::seconds(10))) {
            RCLCPP_ERROR(this->get_logger(), "Action server not available after waiting");
            return;
        }

        // Create goal
        auto goal_msg = Fibonacci::Goal();
        goal_msg.order = 10;

        // Set callbacks
        auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions();
        send_goal_options.goal_response_callback =
            std::bind(&FibonacciActionClient::goal_response_callback, this, _1);
        send_goal_options.feedback_callback =
            std::bind(&FibonacciActionClient::feedback_callback, this, _1, _2);
        send_goal_options.result_callback =
            std::bind(&FibonacciActionClient::result_callback, this, _1);
        
        // Send goal
        RCLCPP_INFO(this->get_logger(), "Sending goal");
        this->future_goal_handle_ =
            this->client_ptr_->async_send_goal(goal_msg, send_goal_options);
            
        // Cancel timer after first execution
        this->timer_->cancel();
    }

private:
    rclcpp_action::Client<Fibonacci>::SharedPtr client_ptr_;
    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp_action::ClientGoalHandle<Fibonacci>::SharedPtr future_goal_handle_;

    void goal_response_callback(std::shared_future<GoalHandleFibonacci::SharedPtr> future) {
        auto goal_handle = future.get();
        if (!goal_handle) {
            RCLCPP_ERROR(this->get_logger(), "Goal was rejected by server");
        } else {
            RCLCPP_INFO(this->get_logger(), "Goal accepted by server, waiting for result");
        }
    }

    void feedback_callback(
        GoalHandleFibonacci::SharedPtr,
        const std::shared_ptr<const Fibonacci::Feedback> feedback)
    {
        RCLCPP_INFO(this->get_logger(), "Received feedback: %s",
                   std::to_string(feedback->sequence.back()).c_str());
    }

    void result_callback(const GoalHandleFibonacci::WrappedResult & result) {
        switch (result.code) {
            case rclcpp_action::ResultCode::SUCCEEDED:
                RCLCPP_INFO(this->get_logger(), "Goal succeeded");
                break;
            case rclcpp_action::ResultCode::ABORTED:
                RCLCPP_ERROR(this->get_logger(), "Goal was aborted");
                return;
            case rclcpp_action::ResultCode::CANCELED:
                RCLCPP_ERROR(this->get_logger(), "Goal was canceled");
                return;
            default:
                RCLCPP_ERROR(this->get_logger(), "Unknown result code");
                return;
        }

        RCLCPP_INFO(this->get_logger(), "Result received:");
        for (auto number : result.result->sequence) {
            RCLCPP_INFO(this->get_logger(), " %ld", number);
        }
    }
};
```

## Custom Action Types

### Creating Custom Actions

1. Create an action directory in your package
2. Define your action in a `.action` file:
```
# Navigation.action
float32 target_x
float32 target_y
float32 target_theta
---
string status
int32 error_code
---
float32 current_x
float32 current_y
float32 current_theta
float32 distance_remaining
```

3. Update your package.xml:
```xml
<build_depend>rosidl_default_generators</build_depend>
<exec_depend>rosidl_default_runtime</exec_depend>
<member_of_group>rosidl_interface_packages</member_of_group>
```

4. Update CMakeLists.txt:
```cmake
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "action/Navigation.action"
)
```

### Using Custom Actions

```python
from my_robot_msgs.action import Navigation

class NavigationActionServer(Node):
    def __init__(self):
        super().__init__('navigation_action_server')
        self._action_server = ActionServer(
            self,
            Navigation,
            'navigate_to_pose',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        # Validate goal
        if goal_request.target_x < 0 or goal_request.target_y < 0:
            self.get_logger().warn('Invalid navigation goal')
            return GoalResponse.REJECT
        
        self.get_logger().info(f'Accepting navigation goal: {goal_request.target_x}, {goal_request.target_y}')
        return GoalResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing navigation goal...')
        
        feedback_msg = Navigation.Feedback()
        result = Navigation.Result()
        
        # Simulate navigation
        for step in range(100):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result.status = 'CANCELED'
                result.error_code = 1
                return result
            
            # Update feedback
            feedback_msg.current_x = goal_handle.request.target_x * (step / 100.0)
            feedback_msg.current_y = goal_handle.request.target_y * (step / 100.0)
            feedback_msg.distance_remaining = (1 - step/100.0) * 10.0  # Simplified
            
            goal_handle.publish_feedback(feedback_msg)
            
            # Simulate movement
            time.sleep(0.1)
        
        # Success
        goal_handle.succeed()
        result.status = 'SUCCESS'
        result.error_code = 0
        return result
```

## Advanced Action Patterns

### Action with Priority and Queueing

```python
import queue
from rclpy.action import ActionServer, GoalResponse
from example_interfaces.action import Fibonacci

class PriorityActionServer(Node):
    def __init__(self):
        super().__init__('priority_action_server')
        
        # Priority queue for goals
        self.goal_queue = queue.PriorityQueue()
        self.current_goal = None
        
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        # For this example, higher order = higher priority (negative for min-heap)
        priority = -goal_request.order
        self.goal_queue.put((priority, goal_request))
        
        # Accept all goals to handle priority internally
        return GoalResponse.ACCEPT

    def execute_callback(self, goal_handle):
        # This would implement priority-based goal handling
        pass

    def cancel_callback(self, goal_handle):
        return CancelResponse.ACCEPT
```

### Action with Multiple Feedback Types

```python
from example_interfaces.action import Fibonacci

class DetailedFeedbackServer(Node):
    def __init__(self):
        super().__init__('detailed_feedback_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci_detailed',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        self.get_logger().info(f'Received Fibonacci goal for order {goal_request.order}')
        return GoalResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing Fibonacci goal...')
        
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]
        
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = Fibonacci.Result()
                result.sequence = feedback_msg.sequence
                return result

            # Update sequence
            next_value = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]
            feedback_msg.sequence.append(next_value)
            
            # Publish detailed feedback
            goal_handle.publish_feedback(feedback_msg)
            
            # Log progression
            self.get_logger().info(f'Fibonacci step {i+1}: {next_value}')
            
            # Simulate computation time
            time.sleep(0.5)

        # Success
        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Fibonacci complete: {result.sequence}')
        
        return result
```

## Action Error Handling and Recovery

### Robust Action Server with Error Handling

```python
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from example_interfaces.action import Fibonacci

class RobustActionServer(Node):
    def __init__(self):
        super().__init__('robust_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci_robust',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        # Validate goal parameters
        if goal_request.order < 0:
            self.get_logger().error(f'Invalid order value: {goal_request.order}')
            return GoalResponse.REJECT
        
        if goal_request.order > 100:  # Prevent excessive computation
            self.get_logger().warn(f'Large order value: {goal_request.order}')
        
        self.get_logger().info(f'Accepting goal with order: {goal_request.order}')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        self.get_logger().info(f'Canceling goal with order: {goal_handle.request.order}')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Starting robust execution...')
        
        feedback_msg = Fibonacci.Feedback()
        result = Fibonacci.Result()
        
        try:
            # Initialize sequence
            if goal_handle.request.order <= 0:
                result.sequence = []
                goal_handle.succeed()
                return result
            elif goal_handle.request.order == 1:
                result.sequence = [0]
                goal_handle.succeed()
                return result
            else:
                feedback_msg.sequence = [0, 1]

            # Execute with error handling
            for i in range(1, goal_handle.request.order):
                # Check for cancellation
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    result.sequence = feedback_msg.sequence
                    return result

                # Calculate next Fibonacci number
                next_value = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]
                
                # Check for overflow (simplified)
                if next_value < 0:  # Simplified overflow check
                    self.get_logger().error('Overflow detected in Fibonacci calculation')
                    goal_handle.abort()
                    result.sequence = feedback_msg.sequence
                    return result

                feedback_msg.sequence.append(next_value)
                
                # Publish feedback periodically
                if i % 5 == 0:  # Publish every 5 steps to reduce overhead
                    goal_handle.publish_feedback(feedback_msg)
                
                # Simulate processing time
                time.sleep(0.01)

        except Exception as e:
            self.get_logger().error(f'Error during execution: {e}')
            goal_handle.abort()
            result.sequence = feedback_msg.sequence
            return result

        # Success
        goal_handle.succeed()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Execution completed successfully with {len(result.sequence)} numbers')
        
        return result
```

## Action Monitoring and Debugging

### Command-Line Tools for Actions

```bash
# List all actions
ros2 action list

# Get information about a specific action
ros2 action info /fibonacci

# Send a goal to an action
ros2 action send_goal /fibonacci example_interfaces/action/Fibonacci "{order: 5}"

# Show action type definition
ros2 interface show example_interfaces/action/Fibonacci
```

### Action Type Information

```bash
# View the structure of an action
ros2 interface show example_interfaces/action/Fibonacci
```

## Performance Considerations

### Efficient Action Implementation

```python
import time
from rclpy.action import ActionServer
from example_interfaces.action import Fibonacci

class EfficientActionServer(Node):
    def __init__(self):
        super().__init__('efficient_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci_efficient',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        # Quick validation without heavy computation
        if goal_request.order < 0 or goal_request.order > 1000:
            return GoalResponse.REJECT
        return GoalResponse.ACCEPT

    def execute_callback(self, goal_handle):
        start_time = time.time()
        
        feedback_msg = Fibonacci.Feedback()
        result = Fibonacci.Result()
        
        # Optimize feedback frequency based on task length
        feedback_interval = max(1, goal_handle.request.order // 20)  # Max 20 feedbacks
        
        try:
            # Pre-allocate list if possible
            if goal_handle.request.order > 0:
                sequence = [0] * goal_handle.request.order
                if goal_handle.request.order > 1:
                    sequence[1] = 1
                
                for i in range(2, goal_handle.request.order):
                    if goal_handle.is_cancel_requested:
                        goal_handle.canceled()
                        result.sequence = sequence[:i]
                        return result

                    sequence[i] = sequence[i-1] + sequence[i-2]
                    
                    # Send feedback at intervals to reduce overhead
                    if i % feedback_interval == 0:
                        feedback_msg.sequence = sequence[:i+1]
                        goal_handle.publish_feedback(feedback_msg)
            else:
                sequence = []

        except Exception as e:
            self.get_logger().error(f'Execution failed: {e}')
            goal_handle.abort()
            result.sequence = sequence
            return result

        # Success
        goal_handle.succeed()
        result.sequence = sequence
        end_time = time.time()
        
        self.get_logger().info(
            f'Completed Fibonacci({len(result.sequence)}) in {end_time-start_time:.2f}s')
        
        return result
```

## Best Practices for Actions

1. **Appropriate Use**: Use actions for long-running, goal-oriented tasks that need feedback
2. **Goal Validation**: Always validate goal parameters in goal_callback
3. **Cancellation Support**: Handle cancellation requests appropriately
4. **Feedback Frequency**: Balance feedback frequency to avoid network overhead
5. **Error Handling**: Implement proper error handling and recovery
6. **Resource Management**: Manage resources properly in long-running tasks
7. **Testing**: Test cancellation, preemption, and error scenarios

## Summary

This submodule covered ROS 2 actions in detail, including their structure, implementation in Python and C++, custom action types, error handling, and best practices. Actions are ideal for long-running tasks that require feedback and can be canceled. In the next submodule, we'll explore when to use each communication pattern (topics, services, actions) and their appropriate applications.
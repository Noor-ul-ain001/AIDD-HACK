---

sidebar_position: 4

---



# 2.4: Simulation Practical Exercises

## Overview

This submodule provides hands-on exercises to apply the simulation concepts learned in the previous submodules. You'll create a complete simulation environment, implement robot control, work with sensors in simulation, and integrate everything with ROS 2.

## Learning Objectives

By the end of this submodule, you will:
- Build a complete simulation environment from scratch
- Implement robot navigation in simulation
- Work with simulated sensor data
- Create custom Gazebo plugins
- Integrate simulation with ROS 2 control systems
- Debug common simulation issues

## Exercise 1: Complete Simulation Environment Setup

### Objective
Create a complete simulation environment with a robot, world, and necessary ROS 2 integration.

### Step 1: Create Package Structure

First, let's create the necessary directories for our simulation package:

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python simulation_exercises
cd simulation_exercises
```

### Step 2: Create World Files

Create a directory for our worlds and create a basic world file `simulation_exercises/worlds/robotics_lab.sdf`:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="robotics_lab">
    <!-- Include standard models -->
    <include>
      <uri>model://ground_plane</uri>
    </include>
    
    <include>
      <uri>model://sun</uri>
    </include>
    
    <!-- Physics configuration -->
    <physics name="ode" default="0" type="ode">
      <gravity>0 0 -9.8</gravity>
      <ode>
        <solver>
          <type>quick</type>
          <iters>100</iters>
          <sor>1.3</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>
    
    <!-- Add a basic lab environment with obstacles -->
    <!-- Walls -->
    <model name="wall_1">
      <static>true</static>
      <pose>0 5 1 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.6 0.6 0.6 1</ambient>
            <diffuse>0.6 0.6 0.6 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
    
    <model name="wall_2">
      <static>true</static>
      <pose>0 -5 1 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.6 0.6 0.6 1</ambient>
            <diffuse>0.6 0.6 0.6 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
    
    <model name="wall_3">
      <static>true</static>
      <pose>5 0 1 0 0 1.57</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.6 0.6 0.6 1</ambient>
            <diffuse>0.6 0.6 0.6 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
    
    <model name="wall_4">
      <static>true</static>
      <pose>-5 0 1 0 0 1.57</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>10 0.2 2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.6 0.6 0.6 1</ambient>
            <diffuse>0.6 0.6 0.6 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
    
    <!-- Add obstacles -->
    <model name="obstacle_1">
      <static>false</static>
      <pose>2 2 0.2 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.4 0.4 0.4</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.4 0.4 0.4</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.2 0.2 1</ambient>
            <diffuse>0.8 0.2 0.2 1</diffuse>
          </material>
        </visual>
        <inertial>
          <mass>1</mass>
          <inertia>
            <ixx>0.0133</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.0133</iyy>
            <iyz>0</iyz>
            <izz>0.0133</izz>
          </inertia>
        </inertial>
      </link>
    </model>
    
    <model name="obstacle_2">
      <static>false</static>
      <pose>-2 -2 0.5 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <cylinder>
              <radius>0.2</radius>
              <length>1.0</length>
            </cylinder>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <cylinder>
              <radius>0.2</radius>
              <length>1.0</length>
            </cylinder>
          </geometry>
          <material>
            <ambient>0.2 0.8 0.2 1</ambient>
            <diffuse>0.2 0.8 0.2 1</diffuse>
          </material>
        </visual>
        <inertial>
          <mass>2</mass>
          <inertia>
            <ixx>0.15</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.15</iyy>
            <iyz>0</iyz>
            <izz>0.1</izz>
          </inertia>
        </inertial>
      </link>
    </model>
    
    <!-- Add a charging station (special area) -->
    <model name="charging_station">
      <static>true</static>
      <pose>4 -4 0.05 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1.0 1.0 0.1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1.0 1.0 0.1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.2 1</ambient>
            <diffuse>0.8 0.8 0.2 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### Step 3: Create Robot Model

Create the robot URDF file `simulation_exercises/urdf/differential_drive_robot.urdf`:

```xml
<?xml version="1.0"?>
<robot name="diff_drive_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">
  
  <!-- Properties -->
  <xacro:property name="M_PI" value="3.1415926535897931"/>
  <xacro:property name="base_width" value="0.3"/>
  <xacro:property name="base_length" value="0.4"/>
  <xacro:property name="base_height" value="0.15"/>
  <xacro:property name="wheel_radius" value="0.05"/>
  <xacro:property name="wheel_width" value="0.025"/>
  <xacro:property name="wheel_mass" value="0.2"/>
  <xacro:property name="base_mass" value="5.0"/>
  
  <!-- Base link -->
  <link name="base_link">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
      <material name="blue">
        <color rgba="0.0 0.0 0.8 1.0"/>
      </material>
    </visual>
    
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
    </collision>
    
    <inertial>
      <mass value="${base_mass}"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.2"/>
    </inertial>
  </link>
  
  <!-- Base footprint -->
  <link name="base_footprint">
    <visual>
      <geometry>
        <cylinder radius="0.01" length="0.001"/>
      </geometry>
      <material name="white">
        <color rgba="1.0 1.0 1.0 1.0"/>
      </material>
    </visual>
    
    <collision>
      <origin xyz="0 0 0.05" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="${base_width/2}" length="0.1"/>
      </geometry>
    </collision>
    
    <inertial>
      <mass value="0.0001"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>
    </inertial>
  </link>
  
  <!-- Joint: base_footprint to base_link -->
  <joint name="base_footprint_joint" type="fixed">
    <parent link="base_footprint"/>
    <child link="base_link"/>
    <origin xyz="0 0 ${base_height/2}" rpy="0 0 0"/>
  </joint>
  
  <!-- Macro for wheels -->
  <xacro:macro name="wheel" params="prefix reflect">
    <link name="${prefix}_wheel_link">
      <visual>
        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
        <material name="black">
          <color rgba="0.0 0.0 0.0 1.0"/>
        </material>
      </visual>
      
      <collision>
        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
      </collision>
      
      <inertial>
        <mass value="${wheel_mass}"/>
        <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.002"/>
      </inertial>
    </link>
    
    <joint name="${prefix}_wheel_joint" type="continuous">
      <parent link="base_link"/>
      <child link="${prefix}_wheel_link"/>
      <origin xyz="${base_length/2 - wheel_width/2} ${reflect * base_width/2} -${base_height/2}" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
    </joint>
  </xacro:macro>
  
  <!-- Create wheels -->
  <xacro:wheel prefix="left" reflect="1"/>
  <xacro:wheel prefix="right" reflect="-1"/>
  
  <!-- Camera link -->
  <link name="camera_link">
    <visual>
      <geometry>
        <box size="0.05 0.1 0.03"/>
      </geometry>
      <material name="red">
        <color rgba="0.8 0.0 0.0 1.0"/>
      </material>
    </visual>
    
    <collision>
      <geometry>
        <box size="0.05 0.1 0.03"/>
      </geometry>
    </collision>
    
    <inertial>
      <mass value="0.05"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>
    </inertial>
  </link>
  
  <joint name="camera_joint" type="fixed">
    <parent link="base_link"/>
    <child link="camera_link"/>
    <origin xyz="${base_length/2 - 0.025} 0 ${base_height/2}" rpy="0 0 0"/>
  </joint>
  
  <!-- IMU link -->
  <link name="imu_link">
    <inertial>
      <mass value="0.01"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>
    </inertial>
  </link>
  
  <joint name="imu_joint" type="fixed">
    <parent link="base_link"/>
    <child link="imu_link"/>
    <origin xyz="0 0 ${base_height/4}" rpy="0 0 0"/>
  </joint>
  
  <!-- Gazebo plugins -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
  </gazebo>
  
  <gazebo reference="left_wheel_link">
    <material>Gazebo/Black</material>
    <mu1>1.0</mu1>
    <mu2>1.0</mu2>
  </gazebo>
  
  <gazebo reference="right_wheel_link">
    <material>Gazebo/Black</material>
    <mu1>1.0</mu1>
    <mu2>1.0</mu2>
  </gazebo>
  
  <gazebo reference="camera_link">
    <material>Gazebo/Red</material>
  </gazebo>

  <!-- Differential drive controller plugin -->
  <gazebo>
    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">
      <update_rate>30</update_rate>
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>
      <wheel_separation>${base_width}</wheel_separation>
      <wheel_diameter>${2 * wheel_radius}</wheel_diameter>
      <max_wheel_torque>20</max_wheel_torque>
      <max_wheel_acceleration>1.0</max_wheel_acceleration>
      <command_topic>cmd_vel</command_topic>
      <odometry_topic>odom</odometry_topic>
      <odometry_frame>odom</odometry_frame>
      <robot_base_frame>base_footprint</robot_base_frame>
      <publish_odom>true</publish_odom>
      <publish_odom_tf>true</publish_odom_tf>
      <publish_wheel_tf>false</publish_wheel_tf>
    </plugin>
  </gazebo>

  <!-- Camera plugin -->
  <gazebo reference="camera_link">
    <sensor name="camera" type="camera">
      <update_rate>30</update_rate>
      <camera name="head">
        <horizontal_fov>1.047</horizontal_fov>
        <image>
          <width>640</width>
          <height>480</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.1</near>
          <far>10</far>
        </clip>
      </camera>
      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
        <frame_name>camera_link</frame_name>
        <min_depth>0.1</min_depth>
        <max_depth>10</max_depth>
      </plugin>
    </sensor>
  </gazebo>

  <!-- IMU plugin -->
  <gazebo reference="imu_link">
    <sensor name="imu_sensor" type="imu">
      <always_on>true</always_on>
      <update_rate>50</update_rate>
      <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">
        <frame_name>imu_link</frame_name>
        <topic>imu/data</topic>
        <serviceName>imu_service</serviceName>
      </plugin>
    </sensor>
  </gazebo>
</robot>
```

### Step 4: Create Controller Configuration

Create controller configuration file `simulation_exercises/config/diff_drive_controller.yaml`:

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    use_sim_time: true

    diff_drive_controller:
      type: diff_drive_controller/DiffDriveController

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

diff_drive_controller:
  ros__parameters:
    left_wheel_names: ["left_wheel_joint"]
    right_wheel_names: ["right_wheel_joint"]
    wheel_separation: 0.3
    wheel_radius: 0.05
    publish_rate: 50.0

    # Velocity commands
    cmd_vel_timeout: 0.5
    linear.x.has_velocity_limits: true
    linear.x.has_acceleration_limits: true
    linear.x.has_jerk_limits: false
    linear.x.max_velocity: 1.0
    linear.x.min_velocity: -1.0
    linear.x.max_acceleration: 2.0
    linear.x.min_acceleration: -2.0
    linear.x.max_jerk: 0.0
    linear.x.min_jerk: 0.0

    angular.z.has_velocity_limits: true
    angular.z.has_acceleration_limits: true
    angular.z.has_jerk_limits: false
    angular.z.max_velocity: 1.0
    angular.z.min_velocity: -1.0
    angular.z.max_acceleration: 2.0
    angular.z.min_acceleration: -2.0
    angular.z.max_jerk: 0.0
    angular.z.min_jerk: 0.0
```

## Exercise 2: Robot Control in Simulation

### Objective
Implement robot control using ROS 2 messages to move the robot in the simulation environment.

Create `simulation_exercises/simulation_exercises/robot_controller.py`:

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist, Vector3
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
from std_msgs.msg import String
import math

class RobotController(Node):
    def __init__(self):
        super().__init__('robot_controller')
        
        # Create publishers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # Create subscribers
        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        
        # TF buffer and listener for transforms
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        
        # Robot state
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_theta = 0.0
        self.scan_ranges = []
        
        # Control parameters
        self.linear_speed = 0.2  # m/s
        self.angular_speed = 0.3  # rad/s
        self.safe_distance = 0.5  # meters
        self.target_x = 3.0  # Target x position
        self.target_y = 2.0  # Target y position
        
        # Create timer for control loop
        self.timer = self.create_timer(0.1, self.control_loop)  # 10 Hz
        
        self.get_logger().info('Robot Controller initialized')

    def odom_callback(self, msg):
        """Update robot pose from odometry"""
        self.current_x = msg.pose.pose.position.x
        self.current_y = msg.pose.pose.position.y
        
        # Convert quaternion to yaw
        q = msg.pose.pose.orientation
        siny_cosp = 2 * (q.w * q.z + q.x * q.y)
        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)
        self.current_theta = math.atan2(siny_cosp, cosy_cosp)

    def scan_callback(self, msg):
        """Update sensor data"""
        self.scan_ranges = msg.ranges

    def control_loop(self):
        """Main control loop"""
        # Calculate distance to target
        dx = self.target_x - self.current_x
        dy = self.target_y - self.current_y
        distance_to_target = math.sqrt(dx*dx + dy*dy)
        
        # Calculate angle to target
        angle_to_target = math.atan2(dy, dx)
        angle_diff = angle_to_target - self.current_theta
        
        # Normalize angle
        while angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        while angle_diff < -math.pi:
            angle_diff += 2 * math.pi
        
        # Check if close to target
        if distance_to_target < 0.3:
            self.get_logger().info('Reached target position!')
            self.stop_robot()
            return
        
        # Determine if obstacle is ahead
        obstacle_ahead = self.check_obstacle_ahead()
        
        # Create twist command
        twist = Twist()
        
        if obstacle_ahead:
            # If obstacle ahead, rotate to avoid
            twist.linear.x = 0.0
            twist.angular.z = self.angular_speed
        elif abs(angle_diff) > 0.2:  # 0.2 radians ~ 11.5 degrees
            # If not aligned with target, rotate
            twist.linear.x = 0.0
            twist.angular.z = self.angular_speed if angle_diff > 0 else -self.angular_speed
        else:
            # Move toward target
            twist.linear.x = self.linear_speed
            twist.angular.z = 0.0
        
        # Publish command
        self.cmd_vel_pub.publish(twist)
        
        # Log current status
        self.get_logger().info(
            f'Position: ({self.current_x:.2f}, {self.current_y:.2f}), '
            f'Heading: {self.current_theta:.2f}, '
            f'Distance to target: {distance_to_target:.2f}, '
            f'Obstacle ahead: {obstacle_ahead}')

    def check_obstacle_ahead(self):
        """Check if there is an obstacle ahead based on laser scan"""
        if not self.scan_ranges:
            return False
            
        # Check the front 30 degrees of the laser scan
        front_start = len(self.scan_ranges) // 2 - 15  # -15 degrees from center
        front_end = len(self.scan_ranges) // 2 + 15    # +15 degrees from center
        
        if front_start < 0:
            front_start = 0
        if front_end >= len(self.scan_ranges):
            front_end = len(self.scan_ranges) - 1
        
        # Check if any of the front readings are within safe distance
        for i in range(front_start, front_end):
            if self.scan_ranges[i] < self.safe_distance and not math.isnan(self.scan_ranges[i]):
                return True
        
        return False

    def stop_robot(self):
        """Stop the robot"""
        twist = Twist()
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.cmd_vel_pub.publish(twist)

def main(args=None):
    rclpy.init(args=args)
    controller = RobotController()
    
    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        controller.get_logger().info('Shutting down robot controller...')
    finally:
        controller.stop_robot()
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 3: Sensor Integration and Processing

### Objective
Process data from multiple simulated sensors and implement basic sensor fusion techniques.

Create `simulation_exercises/simulation_exercises/sensor_processor.py`:

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Imu
from nav_msgs.msg import Odometry
from geometry_msgs.msg import PointStamped, Vector3
from visualization_msgs.msg import Marker
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
import math
import numpy as np
from collections import deque
import statistics

class SensorProcessor(Node):
    def __init__(self):
        super().__init__('sensor_processor')
        
        # Create subscribers for various sensors
        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)
        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        
        # Create publishers
        self.obstacle_pub = self.create_publisher(PointStamped, '/obstacle_position', 10)
        self.marker_pub = self.create_publisher(Marker, '/obstacle_marker', 10)
        
        # TF buffer and listener
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        
        # Data storage
        self.scan_ranges = []
        self.imu_data = {'orientation': None, 'angular_velocity': None, 'linear_acceleration': None}
        self.odom_data = {'position': None, 'velocity': None}
        self.obstacle_history = deque(maxlen=10)  # Keep last 10 obstacle readings
        
        # Sensor parameters
        self.safe_distance = 0.8  # meters
        self.min_obstacle_size = 0.3  # meters to be considered an obstacle
        
        # Create timer for processing
        self.timer = self.create_timer(0.5, self.process_sensor_data)  # 2 Hz
        
        self.get_logger().info('Sensor Processor initialized')

    def scan_callback(self, msg):
        """Process laser scan data"""
        self.scan_ranges = msg.ranges
        self.scan_angle_min = msg.angle_min
        self.scan_angle_max = msg.angle_max
        self.scan_angle_increment = msg.angle_increment
        self.scan_range_min = msg.range_min
        self.scan_range_max = msg.range_max

    def imu_callback(self, msg):
        """Process IMU data"""
        self.imu_data = {
            'orientation': msg.orientation,
            'angular_velocity': msg.angular_velocity,
            'linear_acceleration': msg.linear_acceleration
        }

    def odom_callback(self, msg):
        """Process odometry data"""
        self.odom_data = {
            'position': msg.pose.pose.position,
            'velocity': msg.twist.twist.linear
        }

    def process_sensor_data(self):
        """Main processing function"""
        if not self.scan_ranges:
            self.get_logger().warn('No laser data available')
            return
        
        # Process laser scan to detect obstacles
        obstacles = self.detect_obstacles()
        
        # Publish obstacle data if any found
        if obstacles:
            # Average the obstacle positions to smooth readings
            avg_x = statistics.mean([obs['x'] for obs in obstacles])
            avg_y = statistics.mean([obs['y'] for obs in obstacles])
            
            # Create and publish obstacle marker
            self.publish_obstacle_marker(avg_x, avg_y)
            
            # Store obstacle for history
            self.obstacle_history.append({'x': avg_x, 'y': avg_y, 'timestamp': self.get_clock().now()})
            
            self.get_logger().info(f'Detected obstacle at ({avg_x:.2f}, {avg_y:.2f})')
        else:
            self.get_logger().info('No obstacles detected')
        
        # Process and log IMU data
        if self.imu_data['linear_acceleration']:
            # Calculate approximate heading change from IMU
            angular_z = self.imu_data['angular_velocity'].z
            self.get_logger().info(f'Angular velocity: {angular_z:.3f} rad/s')
        
        # Process and log odometry data
        if self.odom_data['velocity']:
            linear_speed = math.sqrt(
                self.odom_data['velocity'].x**2 + 
                self.odom_data['velocity'].y**2
            )
            self.get_logger().info(f'Current speed: {linear_speed:.3f} m/s')

    def detect_obstacles(self):
        """Detect obstacles from laser scan data"""
        obstacles = []
        
        if not self.scan_ranges:
            return obstacles
        
        # Group consecutive readings that represent the same obstacle
        current_obstacle = []
        
        for i, range_val in enumerate(self.scan_ranges):
            if range_val < self.safe_distance and not math.isnan(range_val):
                # Calculate angle for this reading
                angle = self.scan_angle_min + i * self.scan_angle_increment
                
                # Convert to Cartesian coordinates (relative to robot)
                x = range_val * math.cos(angle)
                y = range_val * math.sin(angle)
                
                if current_obstacle:
                    # Check if this point is close to the previous one
                    prev_x, prev_y = current_obstacle[-1]
                    distance = math.sqrt((x - prev_x)**2 + (y - prev_y)**2)
                    
                    if distance < 0.2:  # Points within 20cm are part of same obstacle
                        current_obstacle.append((x, y))
                    else:
                        # This is a new obstacle, save previous one if large enough
                        if len(current_obstacle) >= 2:  # At least 2 points to be an obstacle
                            center_x = sum([p[0] for p in current_obstacle]) / len(current_obstacle)
                            center_y = sum([p[1] for p in current_obstacle]) / len(current_obstacle)
                            obstacles.append({'x': center_x, 'y': center_y})
                        
                        # Start new obstacle
                        current_obstacle = [(x, y)]
                else:
                    current_obstacle = [(x, y)]
            else:
                # End of obstacle, save it if large enough
                if current_obstacle and len(current_obstacle) >= 2:
                    center_x = sum([p[0] for p in current_obstacle]) / len(current_obstacle)
                    center_y = sum([p[1] for p in current_obstacle]) / len(current_obstacle)
                    obstacles.append({'x': center_x, 'y': center_y})
                
                current_obstacle = []
        
        # Don't forget the last obstacle if we were in one
        if current_obstacle and len(current_obstacle) >= 2:
            center_x = sum([p[0] for p in current_obstacle]) / len(current_obstacle)
            center_y = sum([p[1] for p in current_obstacle]) / len(current_obstacle)
            obstacles.append({'x': center_x, 'y': center_y})
        
        return obstacles

    def publish_obstacle_marker(self, x, y):
        """Publish visualization marker for detected obstacle"""
        marker = Marker()
        marker.header.frame_id = 'odom'  # Use odom frame for global visualization
        marker.header.stamp = self.get_clock().now().to_msg()
        marker.ns = 'obstacle_detection'
        marker.id = 0
        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        
        marker.pose.position.x = x
        marker.pose.position.y = y
        marker.pose.position.z = 0.1  # Slightly above ground
        marker.pose.orientation.w = 1.0
        
        marker.scale.x = 0.2  # 20cm diameter sphere
        marker.scale.y = 0.2
        marker.scale.z = 0.2
        
        marker.color.a = 0.8  # Alpha
        marker.color.r = 1.0  # Red
        marker.color.g = 0.0
        marker.color.b = 0.0
        
        self.marker_pub.publish(marker)

def main(args=None):
    rclpy.init(args=args)
    processor = SensorProcessor()
    
    try:
        rclpy.spin(processor)
    except KeyboardInterrupt:
        processor.get_logger().info('Shutting down sensor processor...')
    finally:
        processor.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 4: Launch File Integration

### Objective
Create launch files to run the complete simulation environment with all nodes.

Create `simulation_exercises/launch/simulation_exercises.launch.py`:

```python
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, ExecuteProcess, RegisterEventHandler
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from launch.event_handlers import OnProcessExit
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Get the package directory
    pkg_share = get_package_share_directory('simulation_exercises')
    
    # World file path
    world_file = os.path.join(pkg_share, 'worlds', 'robotics_lab.sdf')
    
    # URDF file path
    urdf_file = os.path.join(pkg_share, 'urdf', 'differential_drive_robot.urdf')
    
    # Controller config file path
    controller_config_file = os.path.join(pkg_share, 'config', 'diff_drive_controller.yaml')
    
    # Launch Gazebo with the world
    gazebo = ExecuteProcess(
        cmd=['gazebo', '--verbose', world_file, 
             '-s', 'libgazebo_ros_init.so',
             '-s', 'libgazebo_ros_factory.so'],
        output='screen'
    )
    
    # Robot State Publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='screen',
        parameters=[
            {'use_sim_time': True},
            {'robot_description': open(urdf_file).read()}
        ]
    )
    
    # Spawn entity in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', 'robot_description',
            '-entity', 'diff_drive_robot',
            '-x', '0', '-y', '0', '-z', '0.1'
        ],
        output='screen'
    )
    
    # Robot controller
    robot_controller = Node(
        package='simulation_exercises',
        executable='robot_controller',
        name='robot_controller',
        parameters=[{'use_sim_time': True}],
        output='screen'
    )
    
    # Sensor processor
    sensor_processor = Node(
        package='simulation_exercises',
        executable='sensor_processor',
        name='sensor_processor',
        parameters=[{'use_sim_time': True}],
        output='screen'
    )
    
    # Joint state publisher (for non-controlled joints)
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
        parameters=[{'use_sim_time': True}],
        output='screen'
    )
    
    # Controller manager
    controller_manager = Node(
        package='controller_manager',
        executable='ros2_control_node',
        parameters=[controller_config_file, {'use_sim_time': True}],
        output='screen'
    )
    
    # Load and start controllers
    load_joint_state_broadcaster = ExecuteProcess(
        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',
             'joint_state_broadcaster'],
        output='screen'
    )
    
    load_diff_drive_controller = ExecuteProcess(
        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',
             'diff_drive_controller'],
        output='screen'
    )
    
    return LaunchDescription([
        gazebo,
        robot_state_publisher,
        joint_state_publisher,
        spawn_entity,
        controller_manager,
        load_joint_state_broadcaster,
        load_diff_drive_controller,
        robot_controller,
        sensor_processor,
    ])
```

## Exercise 5: Custom Gazebo Plugin

### Objective
Create a custom Gazebo plugin to simulate specific robot behaviors or environmental conditions.

Create `simulation_exercises/gazebo_plugins/custom_force_plugin.cpp`:

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <ignition/math/Vector3.hh>
#include <rclcpp/rclcpp.hpp>
#include <geometry_msgs/msg/twist.hpp>

namespace gazebo
{
  class CustomForcePlugin : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
      // Store the model pointer for later usage
      this->model = _model;
      
      // Get the first link (chassis) - assuming it's the first link
      this->link = _model->GetLink();
      
      // Listen to the update event. This event is broadcast every
      // simulation iteration.
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&CustomForcePlugin::OnUpdate, this));
          
      std::cout << "CustomForcePlugin loaded for model: " << _model->GetName() << std::endl;
    }

    // Called by the world update start event
    public: void OnUpdate()
    {
      // Apply a small random force to simulate environmental disturbance
      // This makes the simulation more challenging and realistic
      
      // Get current time to apply time-varying forces
      double seconds = this->model->GetWorld()->SimTime().Double();
      
      // Apply a periodic force in the x-direction
      double force_x = 0.1 * sin(seconds);
      double force_y = 0.05 * cos(seconds * 1.5);
      
      // Apply the force to the link's center of mass
      ignition::math::Vector3d force(force_x, force_y, 0);
      this->link->AddForce(force);
    }

    // Pointer to the model
    private: physics::ModelPtr model;
    
    // Pointer to the link
    private: physics::LinkPtr link;
    
    // Event connection
    private: event::ConnectionPtr updateConnection;
  };

  // Register this plugin with the simulator
  GZ_REGISTER_MODEL_PLUGIN(CustomForcePlugin)
}
```

## Exercise 6: Testing and Validation

### Objective
Create a simple test to validate that all components are working correctly.

Create `simulation_exercises/test/simulation_test.py`:

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
import time

class SimulationTest(Node):
    def __init__(self):
        super().__init__('simulation_test')
        
        # Create publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        
        # Test state
        self.test_step = 0
        self.initial_pos = None
        self.scan_received = False
        
        # Create timer for test execution
        self.timer = self.create_timer(1.0, self.run_test)
        
        self.get_logger().info('Simulation Test initialized')

    def odom_callback(self, msg):
        """Store initial position for comparison"""
        if self.initial_pos is None:
            self.initial_pos = (msg.pose.pose.position.x, msg.pose.pose.position.y)

    def scan_callback(self, msg):
        """Confirm scan is being received"""
        self.scan_received = True

    def run_test(self):
        """Run the test sequence"""
        if self.test_step == 0:
            self.get_logger().info('Test Step 0: Verifying sensor data...')
            if self.scan_received:
                self.get_logger().info('✓ Laser scan data is being received')
            else:
                self.get_logger().warn('✗ No laser scan data received')
            
            if self.initial_pos:
                self.get_logger().info(f'✓ Initial position: {self.initial_pos}')
            else:
                self.get_logger().warn('✗ Initial position not received')
            
        elif self.test_step == 1:
            self.get_logger().info('Test Step 1: Sending velocity command...')
            twist = Twist()
            twist.linear.x = 0.5  # Move forward at 0.5 m/s
            self.cmd_vel_pub.publish(twist)
            
        elif self.test_step == 2:
            self.get_logger().info('Test Step 2: Checking robot movement...')
            # Stop the robot
            twist = Twist()
            twist.linear.x = 0.0
            self.cmd_vel_pub.publish(twist)
            
        elif self.test_step == 3:
            self.get_logger().info('Test Sequence Complete')
            self.timer.cancel()
            return
        
        self.test_step += 1

def main(args=None):
    rclpy.init(args=args)
    test_node = SimulationTest()
    
    try:
        rclpy.spin(test_node)
    except KeyboardInterrupt:
        test_node.get_logger().info('Shutting down simulation test...')
    finally:
        test_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercise 7: Package Configuration Files

### Update Package Files

Update `simulation_exercises/package.xml`:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>simulation_exercises</name>
  <version>0.1.0</version>
  <description>Simulation exercises for robotics course</description>
  <maintainer email="user@example.com">User</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>nav_msgs</depend>
  <depend>tf2_ros</depend>
  <depend>tf2_geometry_msgs</depend>
  <depend>visualization_msgs</depend>
  <depend>xacro</depend>
  <depend>gazebo_ros_pkgs</depend>
  <depend>gazebo_plugins</depend>
  <depend>gazebo_dev</depend>
  <depend>robot_state_publisher</depend>
  <depend>joint_state_publisher</depend>
  <depend>controller_manager</depend>
  <depend>diff_drive_controller</depend>

  <buildtool_depend>ament_python</buildtool_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

Update `simulation_exercises/setup.py`:

```python
from setuptools import setup
from glob import glob
import os

package_name = 'simulation_exercises'

setup(
    name=package_name,
    version='0.1.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Include URDF files
        (os.path.join('share', package_name, 'urdf'), glob('urdf/*.urdf')),
        # Include world files
        (os.path.join('share', package_name, 'worlds'), glob('worlds/*.sdf')),
        # Include config files
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
        # Include launch files
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='User',
    maintainer_email='user@example.com',
    description='Simulation exercises for robotics course',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'robot_controller = simulation_exercises.robot_controller:main',
            'sensor_processor = simulation_exercises.sensor_processor:main',
            'simulation_test = simulation_exercises.simulation_test:main',
        ],
    },
)
```

## Exercise 8: Running the Complete Simulation

### Steps to Execute:

1. **Build the package:**
```bash
cd ~/ros2_ws
colcon build --packages-select simulation_exercises
source install/setup.bash
```

2. **Run the complete simulation:**
```bash
ros2 launch simulation_exercises simulation_exercises.launch.py
```

3. **In a separate terminal, visualize the simulation:**
```bash
# To visualize the robot model
ros2 run rviz2 rviz2

# To check topics
ros2 topic list

# To see messages on specific topics
ros2 topic echo /odom
ros2 topic echo /scan
```

4. **Run the test node to verify everything works:**
```bash
ros2 run simulation_exercises simulation_test
```

5. **Try sending manual commands to the robot:**
```bash
# Send velocity commands
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist '{linear: {x: 0.2}, angular: {z: 0.1}}'
```

## Troubleshooting Common Issues

### 1. Robot not moving in simulation

If the robot doesn't respond to velocity commands:

```bash
# Check if the diff_drive_controller is running
ros2 lifecycle list diff_drive_controller

# Check if robot_description is available
ros2 param list | grep robot_description

# Check for errors in the diff_drive_controller
ros2 lifecycle set diff_drive_controller configure
ros2 lifecycle set diff_drive_controller activate
```

### 2. Sensor data not available

If sensor topics are not being published:

```bash
# Check if plugins are loaded
gz model -m diff_drive_robot --info

# Check for Gazebo model plugins
ros2 run gazebo_ros spawn_entity.py -h
```

### 3. TF tree issues

If transforms aren't available:

```bash
# View the TF tree
ros2 run tf2_tools view_frames

# Echo specific transforms
ros2 run tf2_ros tf2_echo odom base_link
```

## Performance Optimization Tips

### 1. Physics Optimization

For better performance, consider reducing physics accuracy:

```xml
<physics name="ode" default="0" type="ode">
  <max_step_size>0.01</max_step_size>  <!-- Increase for performance -->
  <real_time_factor>1.0</real_time_factor>
  <ode>
    <solver>
      <iters>20</iters>  <!-- Reduce for performance -->
      <sor>1.3</sor>
    </solver>
  </ode>
</physics>
```

### 2. Sensor Rate Optimization

Adjust sensor update rates for better performance:

```xml
<sensor name="camera" type="camera">
  <update_rate>15</update_rate>  <!-- Reduce for performance -->
</sensor>
```

## Summary

This practical exercise module covered:

1. **Complete simulation environment setup**: Creating worlds, robots, and integration with ROS 2
2. **Robot control implementation**: Moving robots using ROS 2 messages and control algorithms
3. **Sensor integration and processing**: Working with multiple sensor types and implementing sensor fusion
4. **Launch file integration**: Combining all components into a single launch file
5. **Custom Gazebo plugins**: Extending simulation capabilities with custom plugins
6. **Testing and validation**: Verifying that all components work together
7. **Troubleshooting and optimization**: Common issues and performance tips

These exercises provide hands-on experience with the practical aspects of robot simulation, which is essential for real-world robotics development. You have now built a complete simulation environment with a mobile robot that can navigate and process sensor data in a virtual world.